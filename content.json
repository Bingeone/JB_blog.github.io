{"pages":[{"title":"","text":"唠一唠 ↑↑↑ 点击“唠一唠”试试看！ function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/?c=b', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } }); } ==About me== 简介 爱瞎折腾 喜欢足球运动 非码农业余选手 ==博客简述== 基于Hexo博客系统采用Icarus主题 借鉴其它优秀博主博客改造 本博客主要用于学习记录分享 。。。暂时就这样，后续更新！","link":"/about/index.html"},{"title":"","text":"友链申请须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo头像。 加载中... 本站友链添加信息需求 头像链接: “https://sm.ms/image/E1WNvLfnl47MzAc&quot;站名: “Bingeone”简述: “生命在于折腾，长寿源于静止”网址: “https://bingeone.top/&quot;","link":"/friends/index.html"},{"title":"","text":"看一看，说一说 欢迎畅所欲言，留下宝贵意见","link":"/talking/index.html"},{"title":"bookmark","text":"常用 在线免费图床 在线PhotoShop编辑器 图片裁剪尺寸缩放 在线配色工具 jQuery在线文档 Flutter 中国官网 JSON在线解析 在线webp转换 JPG/PNG压缩 知识星球 Git-book 统计SEO Google统计 百度统计 51LA统计 百度站长平台 百度指数 今日头条站长平台 测试网速 网站测速 SSL 免费证书 在线工具 PP直连 视频地址解析器 视频转GIF 图片裁剪尺寸缩放 图片添加水印文字 JPG/PNG压缩 在线配色工具 在线webp转换 PDF转换加密工具 短链接生成 在线工具【1】 在线文字转语音 在线工具大全【2】 在线工具大全【3】 聚合免费图床 FireFox在线分享 图标工厂 视频压缩 视频图床 插件和接口 天气插件 静态资源公共库 360 静态资源 CDN 库 Font Awesome 图标库 蓝奏云-网盘 HTML5 2D 引擎 免费 API接口查询 公共组件 v-charts图表 chartjs图表 Echarts图表 Zdog--3D组件 一个加载中svg图标库 资源下载类 潘多拉盒子 Mac精品应用下载 计算机图书-PDF itbook-pdf技术书籍下载 壁纸下载 Kindle书籍下载 Gradle下载 装机必备 压缩解压-7zip（Win） 截图工具-ShareX（Win） 牛逼编辑器-VSCode（Win + Mac） PDF阅读器（Win） 腾讯桌面整理（Win） Alfred 效率神器（Mac） 翻译插件-沙拉查词（Chrome） AdBlock 广告拦截（Chrome） Google 上网助手（Chrome） Chrome 清理大师 终端 Terminal 美化（Mac） eZip 压缩工具（Mac） Dash 程序员工具（Mac） Snipaste 截图贴图（Win + Mac） PotPlayer 视频播放器（Win） IINA 视频播放器（Mac） TodoList（Mac + Win） Paste 便捷剪贴板（Mac） Mac 软件汇总大全 TeamViewer远程协助 腾讯柠檬清理（Mac） 开发工具 Modbus-RTU PC版（Win） 串口调试助手-PC版（Win） 串口调试助手-Android版 Android Studio 最新版本（Win + Mac） Android 模拟器 （Mac+Win） 虚拟串口工具（Win） JDK 下载 Ubuntu 桌面版下载 Xmanager 终端模拟 Android 屏幕镜像 VS Code 插件 Code Runner Markdown PDF Remote - SSH GitLens — Git supercharged HTML Boilerplate Neo Vim 官网和文档 Dart 中文文档 Google中国官网 Android系统源码 Android 官方系统源码 Google优酷频道 Modbus 资料汇总大全 stylus pug Flow Babel ESLint Linux命令搜索工具 Linux命令大全（中文） bulma ECMAScript 6 入门 CommonJS规范 MDN Web Docs jQuery在线文档 设计资源 花瓣 站酷 UI中国 Jenny Le's Design 图片编辑海报制作 色盘配色 Gif动图一站式 蓝湖 摄影和壁纸 Photoshop高手之路 1PX 500PX 影视娱乐 清新范-高清电影 91美剧网 电视剧下载 BT 电视剧在线看 达达兔-电影-电视 学习和资料 Flutter 实战（书籍） 微机原理与接口技术 Python最佳实践指南 adb 命令大全 Android官方博客 Android性能优化 美团技术团队 英文资料中文翻译 Android资料网站 各种开发资源大集合汇总 Android 操作系统架构开篇 GitHub 排行榜 关于NB-IoT Modbus资料汇总 Android加入购物车效果 C语言推荐书籍 Android实现相机圆形","link":"/bookmark/index.html"}],"posts":[{"title":"Linux 基础知识","text":"ubuntu 使用技巧 mkdir的技巧 1234#创建 ～/a/b/cmkdir -p ~/a/b/c/#创建多个文件夹mkdir a b c touch 1234#创建文件touch a.txt#在绝对路径中创建文件touch /home/robot/myfile.txt rm 删除 12345#删除文件rm a.txt#删除文件夹rm -rf a或者 trash-put a #将文件移动到回收站 需安装trash-cli cp 复制 12#复制文件夹到指定位置cp -r myfile/ /home/robot/ mv 移动或重命名文件 12345#移动文件夹到指定位置mv myfile /home/robot#重命名文件夹mv myfile myfile01 man 查看linux命令手册 1234#查看ls手册man ls #查看帮助reboot help cd reboot 重启linux系统 shutdown 立即关机 12# 立即关机shotdown -h now ctrl + - 缩小命令行字体大小，ctrl + shift + + 放大 ctrl + alt + T 在桌面快速启动终端 ls -lah 查看当前目录下所有文件详情 time 加执行文件，可以计时运行文件消耗时间 查看ubuntu 挂载详情 df -h 切换用户：su root 更新linux环境：source /etc/environment 软链接如：sudo ln -fs /usr/bin/npm /usr/local/bin/npm linux 端口占用查看和关闭 1234567891011121314151617181920#查看已经连接的服务端口（ESTABLISHED）netstat -a#查看所有的服务端口（LISTEN，ESTABLISHED）netstat -ap#查看指定端口，可以结合grep命令：netstat -ap | grep 8000#还可以使用lsof命令：lsof -i:4000#关闭正在使用端口的程序，用kill + 对应的pidkill -9 pid(号) pip 下载镜像源 123456789#使用方法：pip install requsets -i https://pypi.tuna.tsinghua.edu.cn/simple/ Scipy#镜像源列表：https://mirrors.aliyun.com/pypi/simple/ //阿里https://pypi.tuna.tsinghua.edu.cn/simple/ //清华https://pypi.douban.com/ //豆瓣https://pypi.hustunique.com/ //华中理工大学https://pypi.sdutlinux.org/ //山东理工大学https://pypi.mirrors.ustc.edu.cn/ //中国科学技术大学 ubuntu 系统命令行设置投屏显示 12345678# 使用单显示屏---关闭笔记电脑屏幕（即主屏 LVDS-1不同笔记本可能不一样有eDP-1端口等）xrandr --output LVDS-1 --off #扩展屏幕模式xrandr --output HDMI-1 --right-of LVDS-1 --auto# 切回主屏命令（或者直接合上笔记本再打开）xrandr --output LVDS-1 --auto ​ Ubuntu系统笔记本投屏显示器方法—参考 在linux中制作desktop快捷链接方式 12345678910111213141516171819202122#新建一个连接程序vim typora.desktop[DesktopEntry]Name=Typora#打开软件路径Exec=/opt/Typora/bin/Typora-linux-x64/Typora #类型Type=Application #图标位置Icon=opt/Typora/bin/Typora-linux-x64/resources/assets/iconicon_512x512.png #将程序拷贝到目标地址cp typora.desktop /usr/share/applications/ #将可执行的程序链接到终端的可执行命令，即配置环境ln -s /home/robot/software/Typora/bin/Typora-linux-x64/Typora /usr/sbin/#更改可执行权限(在./Typora文件中)chown root.rootchrome-sandboxchmod 755 chrome-sandbox Linux 系统目录结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172731. / ：根 每一个文件和目录从根目录开始。只有root用户具有该目录下的写权限。请注意，/root是root用户的主目录，这与/不一样2. /bin ：用户二进制文件包含二进制可执行文件。在单用户模式下，你需要使用的常见Linux命令都位于此目录下。系统的所有用户使用的命令都设在这里。例如：ps、ls、ping、grep、cp3. /sbin ：系统二进制文件就像/bin，/sbin同样也包含二进制可执行文件。但是，在这个目录下的linux命令通常由系统管理员使用，对系统进行维护。例如：iptables、reboot、fdisk、ifconfig、swapon命令4. /etc ：配置文件包含所有程序所需的配置文件。也包含了用于启动/停止单个程序的启动和关闭shell脚本。例如：/etc/resolv.conf、/etc/logrotate.confhosts：设备名称（或域名）到ip地址的解析，相当于本地存在的dns功能。5. /dev ：设备文件包含设备文件。这些包括终端设备、USB或连接到系统的任何设备。例如：/dev/tty1、/dev/usbmon06. /proc ：进程信息包含系统进程的相关信息。这是一个虚拟的文件系统，包含有关正在运行的进程的信息。例如：/proc/{pid}目录中包含的与特定pid相关的信息。这是一个虚拟的文件系统，系统资源以文本信息形式存在。例如：/proc/uptime7. /var ：变量文件var代表变量文件。这个目录下可以找到内容可能增长的文件。这包括 - 系统日志文件（/var/log）;包和数据库文件（/var/lib）;电子邮件（/var/mail）;打印队列（/var/spool）;锁文件（/var/lock）;多次重新启动需要的临时文件（/var/tmp）;8. /tem ：临时文件包含系统和用户创建的临时文件。当系统重新启动时，这个目录下的文件都将被删除。9. /usr ：系统应用程序包含二进制文件、库文件、文档和二级程序的源代码。/usr/bin中包含用户程序的二进制文件。如果你在/bin中找不到用户二进制文件，到/usr/bin目录看看。例如：at、awk、cc、less、scp。/usr/sbin中包含系统管理员的二进制文件。如果你在/sbin中找不到系统二进制文件，到/usr/sbin目录看看。例如：atd、cron、sshd、useradd、userdel。/usr/lib中包含了/usr/bin和/usr/sbin用到的库。/usr/local中包含了从源安装的用户程序。例如，当你从源安装Apache，它会在/usr/local/apache2中。10. /home ：HOME 目录所有用户用home目录来存储他们的个人档案。例如：/home/robot/11. /boot ：引导加载程序文件包含引导加载程序相关的文件。内核的initrd、vmlinux、grub文件位于/boot下。例如：initrd.img-2.6.32-24-generic、vmlinuz-2.6.32-24-generic12. /lib ：系统库包含支持位于/bin和/sbin下的二进制文件的库文件.库文件名为 ld或lib.so.*例如：ld-2.11.1.so，libncurses.so.5.713. /opt代表可选的。包含从个别厂商的附加应用程序。附加应用程序应该安装在/opt/或者/opt/的子目录下。14 /mnt ：挂载目录临时安装目录，系统管理员可以挂载文件系统。15 /media ：可移动媒体设备用于挂载可移动设备的临时目录。举例来说，挂载CD-ROM的/media/cdrom，挂载软盘驱动器的/media/floppy;16 /srv ：服务数据srv代表服务。包含服务器特定服务相关的数据。例如，/srv/cvs包含cvs相关的数据。 SSH 协议 123456# 在 ~/.bashrc 文件中配置如下命令：alias name01 = &quot;ssh root@192.168.17.2&quot;注：在终端中输入 name01相当于ssh root@192.168.17.2,其中alias是别名执行过程中需要输入远程许可密码，可以使用ssh-keygen生成本地秘钥，然后将该秘钥复制到远程服务器的authorized_keys文件（在 ~/.ssh位置），内容追加方式添加。 开启ssh远程登陆—在ubuntu上配置流程 123456789101112131415161718192021222324252627282930313233# 下载 opnessh-serversudo apt update //更新源文件sudo apt upgrate //更新软件，升级包文件sudo apt install openssh-server //下载ssh第三包# 激活和参看ssh状态sudo systemctl enable ssh //激活sudo systemctl start ssh //启动sudo systemctl status ssh //查看ssh网络状态#设置firewall允许ssh端口(默认port 22)sudo ufw allow ssh //sudo ufw allow|deny [service] 开启或禁用某个服务sudo ufw enable // 重启firewallsudo ufw status#查看本机网络ip及用户名ifconfigwhoami#在其他平台上通过远程连接工具(xshell等)登陆ubuntussh username@ip //需要输入登陆ubuntu该用户的密码#-------------------------其他操作-------------------------#更改端口号sudo vim /etc/ssh/sshd_config //将port 22 更改成1024之后的端口如(port 2222)，取消#号注释#重启sshsudo /etc/init.d/ssh restart sudo service ssh restart#查看服务状态ps ax | grep sshsudo netstat -ant // 查看与外部连接端口情况#用root账号密码远程登陆需要设置sudo password root (密码) //重置密码sudo vim /etc/ssh/sshd_config //取消root登陆限制，更改成PermitRootLogin yessudo service ssh restart //重启 ubuntu 安装、卸载清除 12345678910111213141516171819202122232425262728# 安装软件sudo apt-get install softname# 卸载软件sudo apt-get remove softname# 卸载清理配置sudo apt-get remove -purge softname# 更新软件信息数据库sudo apt-get update# 系统升级sudo apt-get upgrade# 搜索软件包sudo apt-cache search softname#--------deb 软件的安装卸载--------# 安装deb软件包dpkg -i xxx.deb# 删除deb软件包dpkg -r xxx.deb# 删除deb软件包及配置文件dpkg -r -purge xxx.deb# 查看软件包信息dpkg -info xxx.deb# 查看文件拷贝详情dpkg -L xxx.deb# 查看系统中安装的deb包详情dpkg -l# 重新配置软件包dpkg -reconfigure xxx 删除缓存 123456sudo apt-get autoclean # 清理旧版本的软件缓存sudo apt-get clean # 清理所有软件缓存sudo apt-get autoremove # 删除系统不再使用的孤立软件#--------------------------------# 卸载：tracker(此应用与文件管理器关联)# 这个东西一般我只要安装ubuntu就会第一删掉tracker 他不仅会产生大量的cache文件而且还会影响开机速度。所以在新得利里面删掉就行。 删除多余内核 12345678# 当前Ubuntu系统使用的内核uname -a# 查看所有内核dpkg --get-selections | grep linux# 删除旧内核，注意一般选内核号较小的sudo apt-get remove linux-image-xxxxx-genericsudo apt-get remove linux-headers-xxxxxsudo apt-get remove linux-headers-xxxxx-generic .tar.gz文件解压缩命令—linux文件 1234# 压缩命令tar -zcvf 压缩文件名.tar.gz# 解压缩tar -zxvf 文件名.tar.gz ubuntu中Python虚拟环境 1234567#------------pipenv-# 安装 pip3sudo apt install python3-pip# 安装 pipenvpip install pipenv# 全局安装 pipenvsudo -H pip install -U pipenv","link":"/posts/5655611541.html"},{"title":"Ubuntu20.04下mysql数据库相关操作","text":"安装mysql、重置密码 更新下载源：sudo apt-get update 安装：sudo apt install mysql-server 安装mysql客户端：sudo apt install mysql-client 重启mysql服务：sudo service mysql restart 配置mysql：sudo mysql_secure_installation 接上述内容 接上述内容 用最大权限直接登陆mysql select user,authentication_string,plugin,host from mysql.user; 直接输入重置密码：ALTER USER ‘root‘@’localhost’ IDENTIFIED BY “123456”; 结果大概率报错（ERROR 1819），显示密码过于简单不满足要求 查看密码要求： show variables like ‘validate_password%’; 密码重置配置 mysql&gt; set global validate_password.policy=0; Query OK, 0 rows affected (0.00 sec) mysql&gt; set global validate_password.length=1; Query OK, 0 rows affected (0.01 sec) mysql&gt; alter user ‘root’@‘localhost’ identified by ‘123456’; Query OK, 0 rows affected (0.04 sec) mysql&gt; flush privileges; Query OK, 0 rows affected (0.04 sec) mysql&gt; ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH caching_sha2_password by ‘123456’; Query OK, 0 rows affected (0.04 sec) 详情参考该博文 Ubuntu下彻底卸载mysql数据库1234567891011121、查看相关文件dpkg --list|grep mysql2、卸载sudo apt-get remove mysql-common3、卸载sudo apt-get autoremove --purge mysql-server-5.74、清除残留数据dpkg -l|grep ^rc|awk '{print$2}'|sudo xargs dpkg -P5、查看MySQL的剩余依赖项dpkg --list|grep mysql6、继续删除剩余依赖项sudo apt-get autoremove --purge mysql-apt-config","link":"/posts/1178053341.html"},{"title":"python学习笔记","text":"python内置函数(一) abs() #取绝对值 1234567#abs()是python内置函数,而fabs()是math中的一个模块#fabs() 函数只适用于 float 和 integer 类型，而 abs() 也适用于复数。import mathd = 1+1.0je = 3+4.0jprint(f&quot;d的绝对值:&quot;,abs(d)) #结果为1.4142135623730951print(f&quot;e的绝对值:&quot;,math.fabs(e)) #结果会报错TypeError: can't convert complex to float dict() #创建一个字典 123456789&gt;&gt;&gt; dict() #创建字典{}&gt;&gt;&gt; dict(a=&quot;a&quot;,b=&quot;b&quot;,c=&quot;c&quot;) #key-alue 传入参数{'a': 'a', 'b': 'b', 'c': 'c'}&gt;&gt;&gt; dict(zip([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])) #映射函数方式创建字典{'a': 'A', 'b': 'B', 'c': 'C'}&gt;&gt;&gt; dict([(&quot;one&quot;,1),(&quot;two&quot;,2),(&quot;three&quot;,3)]) #可迭代对象来构造字典，列表为iterable{'one': 1, 'two': 2, 'three': 3} help () #参看对象的帮助信息 1234567891011&gt;&gt;&gt;help('sys') # 查看 sys 模块的帮助……显示帮助信息…… &gt;&gt;&gt;help('str') # 查看 str 数据类型的帮助……显示帮助信息…… &gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt;help(a) # 查看列表 list 帮助信息……显示帮助信息…… &gt;&gt;&gt;help(a.append) # 显示list的append方法的帮助 min () #返回给定参数的最小值 12&gt;&gt;&gt; print (&quot;min(80, 103, 1440) : &quot;, min(80, 103, 1440))min(80, 103, 1440) : 80 setattr() #设置属性值，属性不一定存在 123456789&gt;&gt;&gt; class A():... bar = 1... &gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a,&quot;bar&quot;) #获取属性bar值1&gt;&gt;&gt; setattr(a,&quot;b&quot;,2) #设置属性b值&gt;&gt;&gt; a.b2 all() #用于判断给定的可迭代对象iterable中所有元素是否都为True，元素除了是 0、空、None、False 外都算 True。 1234567891011121314151617#iterable 是元组或列表 空元组、空列表返回值为True，这里要特别注意。&gt;&gt;&gt; all(['a','b','c','d']) # 列表list，元素都不为空或0True&gt;&gt;&gt; all(['a','b','','d']) # 列表list，存在一个空的元素False&gt;&gt;&gt; all([0,2,3,4]) # 列表list，存在一个为0的元素False&gt;&gt;&gt; all(('a','b','c','d')) # 元组tuple，元素都不为空或0True&gt;&gt;&gt; all(('a','b','','d')) # 元组tuple，存在一个空的元素False&gt;&gt;&gt; all((0,1,2,3)) # 列表list，存在一个为0的元素False&gt;&gt;&gt; all([]) # 空列表True&gt;&gt;&gt; all(()) # 空元组True dir() #函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。 12&gt;&gt;&gt;dir() # 获取当前模块的属性列表&gt;&gt;&gt;dir([]) # 参看列表的方法 hex() #函数用于将一个指定数字转换为 16 进制数,返回的是一个字符串，以0x开头 12345678&gt;&gt;&gt; hex(255)'0xff'&gt;&gt;&gt; hex(-42)'-0x2a'&gt;&gt;&gt; hex(12)'0xc'&gt;&gt;&gt; type(hex(12)) #查看类型&lt;class 'str'&gt; next() #返回迭代器的下一个项目，和生成迭代器的 iter() 函数一起使用 1234567891011121314&gt;&gt;&gt; li=[3,6,4,63,5]&gt;&gt;&gt; it = iter(li) #首先获得Iterator对象&gt;&gt;&gt; while True:... y =next(it,&quot;aa&quot;)... print(y)... if y == &quot;aa&quot;:... break...364635aa slice() #函数实现切片对象，主要用在切片操作函数里的参数传递 slice(start, stop[, step])—step间距 123456789101112&gt;&gt;&gt; myslice = slice(3) # 设置截取3个元素的切片&gt;&gt;&gt; mysliceslice(None, 3, None)&gt;&gt;&gt; arr = list(range(6))&gt;&gt;&gt; arr[0,1,2,3,4,5] &gt;&gt;&gt; arr[myslice] # 截取 3 个元素[0,1,2]&gt;&gt;&gt;myslice1 = slice(0,7,2)&gt;&gt;&gt;arr1 = list(range(10))&gt;&gt;&gt;arr1[myslice1][0, 2, 4, 6] any() #函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True 1234567891011121314151617#如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。&gt;&gt;&gt;any(['a', 'b', 'c', 'd']) # 列表list，元素都不为空或0True&gt;&gt;&gt; any(['a', 'b', '', 'd']) # 列表list，存在一个为空的元素True&gt;&gt;&gt; any([0, '', False]) # 列表list,元素全为0,'',falseFalse&gt;&gt;&gt; any(('a', 'b', 'c', 'd')) # 元组tuple，元素都不为空或0True&gt;&gt;&gt; any(('a', 'b', '', 'd')) # 元组tuple，存在一个为空的元素True&gt;&gt;&gt; any((0, '', False)) # 元组tuple，元素全为0,'',falseFalse&gt;&gt;&gt; any([]) # 空列表False&gt;&gt;&gt; any(()) # 空元组False divmod() #接受两个非复数类型的数字，返回商和余数的元组 123456&gt;&gt;&gt; divmod(7,2) //相当于（a//b,a%b）(3, 1)&gt;&gt;&gt; divmod(3,-1.3)(-3.0, -0.9000000000000001)&gt;&gt;&gt; divmod(6,-2)(-3, 0) id() #获取对象的内存地址 1234567891011121314151617181920&gt;&gt;&gt; aa=1&gt;&gt;&gt; id(aa)9788608&gt;&gt;&gt; bb=1 &gt;&gt;&gt; id(bb)9788608&gt;&gt;&gt; a=&quot;whoami&quot;&gt;&gt;&gt; id(a)140185507204528#-------注意--------#在对象内存数字类型较小时，对象的内存地址是一样的，一般情况不一样&gt;&gt;&gt; a = 1234&gt;&gt;&gt; id(a)140185507593328&gt;&gt;&gt; b = 1234&gt;&gt;&gt; id(b)140185507593424&gt;&gt;&gt; b = a&gt;&gt;&gt; id(b)140185507593328 object() #对象，类默认的对象 sorted() #对可迭代的对象(列表，元组)进行排列 12345678910111213141516171819202122232425# sort 和 sorted区别：# sort 对原来的列表排序操作，sorted 对可迭代对象操作并生成新的列表&gt;&gt;&gt; sorted([4,7,2,8])[2, 4, 7, 8]&gt;&gt;&gt; a = [4,7,2,8]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[2, 4, 7, 8]#----------sorted常用-------------&gt;&gt;&gt; sorted({1:&quot;d&quot;,2:&quot;b&quot;,3:&quot;c&quot;,4:&quot;a&quot;}) //接受任何的iterable[1, 2, 3, 4]&gt;&gt;&gt; li = [5,9,3,2,6,8]&gt;&gt;&gt; result_li=sorted(li, key = lambda y:y*-1) //将序&gt;&gt;&gt; result_li[9, 8, 6, 5, 3, 2]&gt;&gt;&gt; sorted(li, reverse = True)[9, 8, 6, 5, 3, 2]&gt;&gt;&gt; sorted(li, reverse = False)[2, 3, 5, 6, 8, 9]#------------实例应用------------# score降序排列，同条件下对name升序&gt;&gt;&gt; d1 = [{'name':'alice', 'score':38}, {'name':'bob', 'score':18}, {'name':'darl', 'score':28}, {'name':'christ', 'score':28}]&gt;&gt;&gt; ll = sorted(d1, key = lambda x:(-x[&quot;score&quot;],x[&quot;name&quot;]))&gt;&gt;&gt; ll[{'name': 'alice', 'score': 38}, {'name': 'christ', 'score': 28}, {'name': 'darl', 'score': 28}, {'name': 'bob', 'score': 18}] ascii() #返回表示对象的字符串，对于字符串中的非 ASCII 字符则返回通过 repr() 函数使用 \\x, \\u 或 \\U 编码的字符 1234&gt;&gt;&gt; ascii('whoami') //与repr()用法相似&quot;'whoami'&quot;&gt;&gt;&gt; print(repr('#'))'#' enumerate() #用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 1234567891011121314151617181920212223#--------列出数据的下标和它本身--------&gt;&gt;&gt; li = ['Spring','Summer','Fall','Winter']&gt;&gt;&gt; list(enumerate(li))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]&gt;&gt;&gt; list(enumerate(li,start=2))[(2, 'Spring'), (3, 'Summer'), (4, 'Fall'), (5, 'Winter')]#---------在for中的应用---------&gt;&gt;&gt; i = 1&gt;&gt;&gt; li = ['one','two','three','four']&gt;&gt;&gt; for element in li:... print(i, li[i])... i +=1... 1 two2 three3 four#或者for i, element in enumerate(li): print(i, element)0 one1 two2 three3 four input() #接受一个标准输入数据，返回string数据类型 1234567891011121314151617181920&gt;&gt;&gt; aa = input(&quot;&gt;&gt;&gt;:&quot;)&gt;&gt;&gt;:123&gt;&gt;&gt; type(aa) //查看aa对象的类型&lt;class 'str'&gt;&gt;&gt;&gt; bb = input(&quot;&gt;&gt;&gt;:&quot;)&gt;&gt;&gt;:string&gt;&gt;&gt; type(bb)&lt;class 'str'&gt;#-------接受多个值-------&gt;&gt;&gt; a,b,c = (input(&quot;请输入三角形三边的长：&quot;).split())请输入三角形三边的长：3 4 5&gt;&gt;&gt; a = int(a)&gt;&gt;&gt; b = int(b)&gt;&gt;&gt; c = int(c)&gt;&gt;&gt; p = (a+b+c)/2&gt;&gt;&gt; p6.0&gt;&gt;&gt; s = (p*(p-a)*(p-b)*(p-c))**0.5&gt;&gt;&gt; print(f&quot;三角形的面积为:{s}&quot;)三角形的面积为:6.0 oct() #将整数转化成8进制字符串，以0o作为前缀 1234&gt;&gt;&gt; oct(12)'0o14'&gt;&gt;&gt; oct(1)'0o1' staticmethod #返回函数的静态方法 12345678910&gt;&gt;&gt; class A(object):... @staticmethod... def f():... print(&quot;hello&quot;)... &gt;&gt;&gt; A.f() // 无实例调用函数hello&gt;&gt;&gt; cobj = A() // 实例化后调用&gt;&gt;&gt; cobj.f()hello bin() #返回一个整数int或者长整数long int的二进制 1234&gt;&gt;&gt; bin(100)'0b1100100'&gt;&gt;&gt; bin(11)'0b1011' eval() #执行一个字符串表达式，并返回表达式的值 1234567&gt;&gt;&gt; a = 3&gt;&gt;&gt; eval(&quot;a+1&quot;) //计算字符串里的内容4&gt;&gt;&gt; eval(&quot;pow(2,3)&quot;)8&gt;&gt;&gt; eval(&quot;3*4&quot;)12 int() # 将一个字符串或数字转换为整型 123456789101112&gt;&gt;&gt; int() //没有参数为00&gt;&gt;&gt; int(3) //3&gt;&gt;&gt; int(4.6) //取整数部分4&gt;&gt;&gt; int(&quot;12&quot;,16) //将十六进制12，转化成十进制18&gt;&gt;&gt; int(&quot;0xa&quot;,16) 10&gt;&gt;&gt; int(&quot;10&quot;,8) //将八进制转化成十进制8 open() #用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError 语法格式： open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 123456789101112file: 必需，文件路径（相对或者绝对路径）。mode: 可选，文件打开模式buffering: 设置缓冲encoding: 一般使用utf8errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型opener:#---------------------------------&gt;&gt;&gt;f = open('test.txt')&gt;&gt;&gt;f.read()&gt;&gt;&gt;f.close() mode 的参数详述：(默认为文本模式，加b就可以用二进，针对图形影视文件) 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 str() #将对象格式化成string 123456&gt;&gt;&gt; dict = {'baidu': 'baidu.com', 'google': 'google.com'} //格式化成字符串&gt;&gt;&gt; str(dict)&quot;{'baidu': 'baidu.com', 'google': 'google.com'}&quot;&gt;&gt;&gt; a = 'bingeone'&gt;&gt;&gt; str(a)'bingeone' bool() #将给定的对象转换成布尔类型，True 或者 False 12345678910&gt;&gt;&gt; bool()False&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(10)True&gt;&gt;&gt; issubclass(bool,int) //bool 是 int的子类True exec() #执行存储在字符串或文件中的python语句 123456789101112131415161718192021222324252627&gt;&gt;&gt; exec(&quot;print('hello,world')&quot;)hello,world&gt;&gt;&gt; exec(&quot;&quot;&quot;for i in range(3):... print(&quot; iter time: %d&quot; %i)... &quot;&quot;&quot;) iter time: 0 iter time: 1 iter time: 2#---------------------------------x = 10expr = &quot;&quot;&quot;z = 30sum = x + y + zprint(sum)&quot;&quot;&quot;def func(): y = 20 exec(expr) // 10+20+30 exec(expr, {'x': 1, 'y': 2}) // 1+2+30 exec(expr, {'x': 1, 'y': 2}, {'y': 3, 'z': 4}) // 1+3+30，两个y取后者，z取定义的，不用传递的4 func()结果：603334 isinstance() #判断一个对象是否是一个已知的类型 与type() 的区别 type() 不会认为子类是父类类型，不考虑继承关系 isinstance() 会认为子类是父类类型，考虑继承关系 可以使用isinstance() 来判断两个类型是否相同 isinstance(object, classinfo) 123456789101112131415161718192021222324&gt;&gt;&gt; a = 2&gt;&gt;&gt; isinstance(a,int)True&gt;&gt;&gt; isinstance(a,str)False&gt;&gt;&gt; isinstance(a,(str,int,list)) // 在元组中满足一个，就返回TrueTrue#基本类型 classinfo：# int，float，bool，complex，str(字符串)，list，dict(字典)，set，tuple#-------------------------------&gt;&gt;&gt; class A:... pass... &gt;&gt;&gt; class B(A): // B类继承A类... pass... &gt;&gt;&gt; isinstance(A(),A) //实例A 和类A 一个类型True&gt;&gt;&gt; type(A()) == ATrue&gt;&gt;&gt; isinstance(B(),A) True&gt;&gt;&gt; type(B()) == AFalse ord() # 返回对应的 ASCII 数值，或者 Unicode 数值，对应的十进制整数。 1234&gt;&gt;&gt; ord('a')97&gt;&gt;&gt; ord('$')36 sum() #对序列进行求和计算 123456&gt;&gt;&gt; sum([1,2,3])6&gt;&gt;&gt; sum((2,3,4),1) //对元组求和后，再加110&gt;&gt;&gt; sum([0,1,2,3,4],2)12 batearray() #返回一个新字节数组 bytearray([source[, encoding[, errors]]]) 1234567891011121314'''如果 source 为整数，则返回一个长度为 source 的初始化数组；如果 source 为字符串，则按照指定的 encoding 将字符串转换为字节序列；如果 source 为可迭代类型，则元素必须为[0 ,255] 中的整数；如果 source 为与 buffer 接口一致的对象，则此对象也可以被用于初始化 bytearray。如果没有输入任何参数，默认就是初始化数组为0个元素。'''#----------------------------------------------------------&gt;&gt;&gt; bytearray()bytearray(b'')&gt;&gt;&gt; bytearray([1,2,3])bytearray(b'\\x01\\x02\\x03')&gt;&gt;&gt; bytearray('hello','utf-8')bytearray(b'hello') filter() #用于过滤序列，过滤不符合条件的元素，返回一个迭代器对象，可以用list将其转化成列表 filter(function, iterrable) 123456789101112131415&gt;&gt;&gt; def is_sqr(n):... return n %2 == 1 //对2取余，求n为奇数... &gt;&gt;&gt; tmp = filter(is_sqr, [1,2,3,4,5,6,7,8])&gt;&gt;&gt; list(tmp)[1, 3, 5, 7]#-------------------------------------------&gt;&gt;&gt; import math //引入math模块&gt;&gt;&gt; def is_sqr(x):... return math.sqrt(x) % 1== 0 //求开平方根得到整数的对象... &gt;&gt;&gt; tmplist = filter(is_sqr, range(1,101))&gt;&gt;&gt; newlist = list(tmplist)&gt;&gt;&gt; newlist[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] issubclass() #用于判断参数class是否是类型参数classinfo的子类 issubclass(class, classinfo) 12345678&gt;&gt;&gt; class A(object):... pass... &gt;&gt;&gt; class B(A):... pass... &gt;&gt;&gt; print(issubclass(B,A))True pow() #返回x^y^ 的值 1234567891011&gt;&gt;&gt; import math&gt;&gt;&gt; math.pow(100,2) //保留一位小数10000.0&gt;&gt;&gt; pow(100,2)10000&gt;&gt;&gt; math.pow(100,-2)0.0001&gt;&gt;&gt; math.pow(2,3)8.0&gt;&gt;&gt; math.pow(100,0)1.0 super() #用于调用父类(超类)的一个方法 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; class A:... def add(self,x):... y = x+1... print(y)... &gt;&gt;&gt; class B(A):... def add(self,x):... super().add(x) //调用父类中的add函数... &gt;&gt;&gt; b = B()&gt;&gt;&gt; b.add(2)3#--------------------------------class FooParent(object): def __init__(self): self.parent = 'I\\'m the parent.' print(&quot;Parent&quot;) def bar(self,message): print(&quot;%s from Parent&quot; % message)class FooChild(FooParent): def __init__(self): super(FooChild,self).__init__() //步骤① print(&quot;Child&quot;) //步骤② def bar(self,message): super(FooChild,self).bar(message) //步骤③ print('Child bar function') //步骤④ print(self.parent) //步骤⑤if __name__ == &quot;__main__&quot;: fooChild = FooChild() //执行结果打印前两个结果 fooChild.bar(&quot;Helloworld&quot;) //打印后三个结果：ParentChildHelloworld from ParentChild bar functionI'm the parent. ​ ​ 内置函数第二部分详见下文。。。内置函数(二) ​","link":"/posts/1847936831.html"},{"title":"Python学习&lt;第一部分&gt;","text":"定义有序的纸牌类 rank: 2345…910JQKA // 牌等级 suit: spades,hearts,clubs,diamonds //花色 除去大小王，实现一幅数字与花色匹配、有序的52组元组的牌类 frenchDeck.py >folded12345678910111213141516import collectionsCard = collections.namedtuple('Card',['rank','suit'])class FrenchDeck: ranks = [str(n) for n in range(2,11)] + list('JQKA') suits = 'spades hearts clubs diamonds'.split() def __init__(self): # 生成一个按花色分组的 52 张牌的列表，其中每个花色各有 13 张不同点数的牌。 self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&gt;&gt;&gt; from frenchDeck import *&gt;&gt;&gt; deck = FrenchDeck()&gt;&gt;&gt; suit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0) //定义黑桃最大、红桃次之、方块再次、梅花最小&gt;&gt;&gt; def spades_high(card):... rank_value = FrenchDeck.ranks.index(card.rank)... return rank_value * len(suit_values) + suit_values[card.suit]... &gt;&gt;&gt; for card in sorted(deck, key=spades_high):... print(card)... Card(rank='2', suit='clubs')Card(rank='2', suit='diamonds')Card(rank='2', suit='hearts')Card(rank='2', suit='spades')Card(rank='3', suit='clubs')Card(rank='3', suit='diamonds')Card(rank='3', suit='hearts')Card(rank='3', suit='spades')...Card(rank='A', suit='clubs')Card(rank='A', suit='diamonds')Card(rank='A', suit='hearts')Card(rank='A', suit='spades')#----------------------------------&gt;&gt;&gt; from frenchDeck import *&gt;&gt;&gt; deck = FrenchDeck()&gt;&gt;&gt; len(deck) //计算对象总数52&gt;&gt;&gt; deck[0]Card(rank='2', suit='spades')&gt;&gt;&gt; deck[1]Card(rank='3', suit='spades')&gt;&gt;&gt; deck[13]Card(rank='2', suit='hearts')&gt;&gt;&gt; deck[-1]Card(rank='A', suit='diamonds')&gt;&gt;&gt; from random import choice&gt;&gt;&gt; choice(deck) //随机获取一组对象Card(rank='J', suit='spades')&gt;&gt;&gt; choice(deck)Card(rank='3', suit='hearts')&gt;&gt;&gt; deck[:3] //索引前三张牌[Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')]&gt;&gt;&gt; deck[12::13] //先抽出索引是 12 的那张牌，然后每隔 13 张牌拿 1 张[Card(rank='A', suit='spades'), Card(rank='A', suit='hearts'), Card(rank='A', suit='clubs'), Card(rank='A', suit='diamonds')]&gt;&gt;&gt; for card in deck: //遍历对象... print(card)... Card(rank='2', suit='spades')Card(rank='3', suit='spades')Card(rank='4', suit='spades')...Card(rank='Q', suit='diamonds')Card(rank='K', suit='diamonds')Card(rank='A', suit='diamonds')&gt;&gt;&gt; for card in reversed(deck): //反向遍历... print(card)... Card(rank='A', suit='diamonds')Card(rank='K', suit='diamonds')Card(rank='Q', suit='diamonds')...Card(rank='4', suit='spades')Card(rank='3', suit='spades')Card(rank='2', suit='spades')&gt;&gt;&gt; Card('Q', 'diamonds') in deck //判断是否在对象组里True&gt;&gt;&gt; Card('2', 'spades') in deckTrue","link":"/posts/1328111034.html"},{"title":"Python面对对象","text":"面向对象简述Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 对象可以包含任意数量和类型的数据。 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 类定义1234567class ClassName: &lt;statement-1&gt; . . . &lt;statement-N&gt;# 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 类对象 类对象的两种用法: 属性引用和实例化 属性引用和Python中所有的属性引用语法相同：object.name 1234567891011121314class Myclass: a = 1 def func(self): return &quot;hello world!&quot;# 实例化类x = Myclass() # 访问类的属性和方法print(&quot;Myclass 类的属性i 为：&quot;, x.i)print(&quot;Myclass 类的方法func为：&quot;, x.func())#结果Myclass 类的属性i 为：1Myclass 类的方法func为: hello world! 类有一个名为 _init_() 的特殊方法（构造方法），该方法在类实例化时会自动调用 12345678class Complex: def __init__(self, realpart, imagpart) self.r = realpart self.i = imagpartx = Complex(3.0, -2,5)print(x.r, x.i)#结果3.0 -2.5 self代表类的实例 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self 123456789class Test: def func(self): print(self) print(self.__class__)y = Text()y.yunc()# 结果&lt;__main__.Test object at 0x7fa4e933a3a0&gt; # 类对象所在的地址&lt;class '__main__.Test'&gt; # self为Test类的实例 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例 123456789101112131415&gt;&gt;&gt; class people:... name = ''... age = '' # 定义基本属性... __weight = 0 # 定义私有属性,私有属性在类外部无法直接进行访问... ... def __init__(self,n, a, w): # 定义构造方法... self.name = n... self.age = a... self.__weight = w... def speak(self):... print(&quot;%s 说: 我 %d 岁。&quot; %(self.name, self.age))... &gt;&gt;&gt; p = people(&quot;xiaoli&quot;, 18, 55) # 类people实例化&gt;&gt;&gt; p.speak() # 调用speak方法（也叫函数）xiaoli 说: 我 18 岁。 继承 子类继承父类的属性和方法（派生类 DerivedClassName，基类 BaseClassName） class DerivedClassName(modname, BaseClassName): 123456789101112131415161718192021&gt;&gt;&gt; class people: # 父类定义... name='' # 定义基本属性... age=''... __weight = 0 # 定义私有属性,私有属性在类外部无法直接进行访问... def __init__(self,n,a,w): # 定义构造方法... slef.name = n... self.age = a... self.__weight = w... def speak(self):... print(&quot;%s说：我%d岁。&quot; %(self.name,self.age))&gt;&gt;&gt; class student(people): # 单继承示例 （子类）... grade = ''... def __init__(self,n,a,w,g):... people.__init__(self,n,a,w) # 调用父类的构函... self.grade = g... def speak(self): # 重写父类的方法... print(&quot;%s 说：我%d岁，我在读%d年级&quot; %(self.name, self.age,self.grade))... &gt;&gt;&gt; s = student(&quot;小李&quot;, 10,50,5)&gt;&gt;&gt; s.speak()小李 说：我10岁，我在读5年级 多继承 class DerivedClassName(Base1, Base2, Base3): 注意圆括号中父类的顺序 若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法 1234567891011121314151617181920212223242526272829303132333435363738class people: name='' age='' __weight=0 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(f&quot;{self.name}说:我{self.age}岁！&quot;)# 单继承示例class student(people): grade='' def __init__(self,n,a,w,g): people.__init__(self,n,a,w) self.grade = g def speak(self): print(f&quot;{self.name}说：我读{self.grade}年级！&quot;)class speaker(): topic='' name='' def __init__(self,n,t): self.name=n self.topic=t def speak(self): print(f&quot;我叫{self.name},我是一个演说家，演讲的主题是{self.topic}&quot;)# 多重继承class sample(speaker,student): def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t)test = sample('Tim',25,65,4,'English')test.speak() # 方法名同，默认调用的是在括号中排前地父类的方法#结果我叫Tim,我是一个演说家，演讲的主题是English 方法重写1234567891011121314class Parent: # 定义父类 def myMethod(self): print('调用父类方法')class Child(Parent): # 定义子类 def myMethod(self): print('调用子类方法')c = Child() # 实例化c.myMethod() # 子类调用方法重写super(Child,c).myMethod() #用子类对象调用，父类覆盖相同的方法 super()函数是用于调用父类#结果调用子类方法调用父类方法 类属性与方法 类的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例 类的私有方法 __private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods 12345678910111213class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount +=1 self.publicCount +=1 print(self.__secretCount)counter = JustCounter()counter.count() # 输出 1counter.count() # 输出 2print(counter.publicCount) #输出 2，反应上次publicCount的值 print(counter.__secretCount) # 私有属性在类外部无法调用，报错 类的私有方法 12345678910111213141516171819class Site: def __init__(self, name, url): self.name =name # public self.url = url # private def who(self): print(f&quot;name: {self.name}&quot;) print(f&quot;url: {self.url}&quot;) def __foo(self): # 私有方法 print('私有方法') def foo(self): # 公开方法 print('公开方法') self.__foo()a = Site('百度','www.baidu.com') # 实例化a.who() # 调whoa.foo() # 调foo及__foo()方法a.__foo() # 私有方法无法访问 类的专用方法 _init_: 构造函数，在生成对象时调用 _del_: 析构函数，释放对象时使用 _repr_: 打印、转换 _setitem_: 按照索引赋值 _getitem_: 按照索引获值 _len_: 获得长度 _cmp_: 比较运算 _call_: 函数调用 _add_: 加运算 _sub_: 减运算 _mul_: 乘运算 _truediv_: 除运算 _mod_: 求余运算 _pow_: 乘方运算 运算符重载 对类的专有方法进行重载 12345678910111213141516class Vector: def __init__(self,a,b): self.a =a self.b=b def __str__(self): return f'Vector ({self.a},{self.b})' def __add__(self,other): return Vector(self.a + other.a,self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print(v1 + v2) # 调用__str__#结果Vector (7,8)","link":"/posts/1372953673.html"},{"title":"Markdown基本使用","text":"文章中图片排版格式 横向排列 12345&lt;div class=&quot;img-x&quot;&gt;-----留空格-----![图片链接](url)-----留空格-----&lt;/div&gt; 竖向排列 12345&lt;div class=&quot;img-y&quot;&gt;-----留空格-----![图片链接](url)-----留空格-----&lt;/div&gt; 横竖排列 12345&lt;div class=&quot;justified-gallery&quot;&gt;-----留空格-----![图片链接](url)-----留空格-----&lt;/div&gt; Markdown图片排版在Hexo注意问题 修改gallery.js文件(没有该文件的新建)： 12345678910111213141516171819// themes/icarus/source/js/gallery.js$(function(){ if (typeof ($.fn.justifiedGallery) === 'function') {+ let justifiedGallery = $('.justified-gallery')+ if(justifiedGallery.length &gt; 0) {+ for (let i = 0; i &lt; justifiedGallery.length; i ++){+ let html = justifiedGallery[i].childNodes[0].innerHTML+ justifiedGallery[i].innerHTML = html+ }+ }+ justifiedGallery.justifiedGallery({ cssAnimation: true, imagesAnimationDuration: 1000 }); } if (typeof ($.fn.lightGallery) === 'function') { $('.article').lightGallery({ selector: '.gallery-item' }); }}) 全局配置hexo文件，在**_config.yml**中添加如下 123456789# 压缩 jsneat_js: enable: true mangle: true output: compress: exclude: #设置忽略压缩文件 - '**/gallery.js' - '**/back-to-top.js' markdown图片排版问题详情 可以参考该博客链接 彩色标题带 粉红色彩带 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;div class=&quot;notification is-danger&quot;&gt;{% endraw %}-----内容-----{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;article class=&quot;message is-danger&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}-----内容-----{% raw %}&lt;/div&gt;{% endraw %} 淡蓝色彩带 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;div class=&quot;notification is-info&quot;&gt;{% endraw %}-----内容-----{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;article class=&quot;message is-info&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}-----内容-----{% raw %}&lt;/div&gt;{% endraw %} 本文同时提供以下语言的翻译： English. 123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-globe-americas mr-2&quot;&gt;&lt;/i&gt;本文同时提供以下语言的翻译： &lt;a href=&quot;/hexo-theme-icarus/uncategorized/getting-started-with-icarus/&quot;&gt;English&lt;/a&gt;. &lt;/div&gt;&lt;/article&gt; 文章内容有误？点击此处提交修改。 12345&lt;article class=&quot;message message-immersive is-warning&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;文章内容有误？点击&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/ppoffice/hexo-theme-icarus/edit/site/source/_posts/zh-CN/Getting-Started.md&quot;&gt;此处&lt;/a&gt;提交修改。 &lt;/div&gt;&lt;/article&gt; 特殊符号插入 如： æ γ Π 复制代码号时，注意带上分号； 特殊符号链接 在Icarus主题文章某个代码块折叠使用方式 \\``` python main.md &gt;folded 在添加代码块的同时，加上代码块名main.md(自定义)，再加上“&gt;folded”,如上所述 (注：在icarus主题博客中main.js 文件已经定义floded功能，用法如上) 相册排版演示 按钮代码演示 Info Success Warning Danger buttons >folded123456&lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;button is-info&quot;&gt;Info&lt;/button&gt; &lt;button class=&quot;button is-success&quot;&gt;Success&lt;/button&gt; &lt;button class=&quot;button is-warning&quot;&gt;Warning&lt;/button&gt; &lt;button class=&quot;button is-danger&quot;&gt;Danger&lt;/button&gt;&lt;/div&gt; 显示一言 ↑↑↑ 试着点击“显示一言”！ function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/?c=b', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } }); } buttons >folded12345678910111213141516&lt;button class=&quot;button is-info&quot; onclick=&quot;showHitokoto(event)&quot;&gt;显示一言&lt;/button&gt;&lt;blockquote class=&quot;hitokoto&quot;&gt;↑↑↑ 试着点击“显示一言”！&lt;/blockquote&gt;&lt;script&gt;function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: '', //此处为存储数据条连接 success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } });}&lt;/script&gt; 样式书写演示看一看，说一说 欢迎畅所欲言，留下宝贵意见 12&lt;center&gt;&lt;font color=#6190e8 face=&quot;黑体&quot; size=5&gt;看一看，说一说&lt;/font&gt;&lt;/center&gt;&lt;center&gt;&lt;font color=#6190e8 face=&quot;黑体&quot; size=5&gt;欢迎畅所欲言，留下宝贵意见&lt;/font&gt;&lt;/center&gt; 函数公式书写演示daima.md >folded123456789101112131415161718这是一个行内公式：\\\\(ax^2+bx+c=0\\\\)。这是另一个行内公式：$ax^2+bx+c&gt;0$。这是一个块状公式：$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$这是另一个块状公式：\\\\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\\\]或者使用\\\\(\\LaTeX\\\\)环境：\\\\begin{equation}A =\\\\begin{bmatrix} a &amp; b \\\\\\\\ c &amp; c\\\\end{bmatrix}\\\\end{equation} 这是一个行内公式：\\(ax^2 + bx + c=0\\)。这是另一个行内公式：$ax^2 + bx + c &gt; 0$。 这是一个块状公式： $$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}​{1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$ ​ 这是另一个块状公式： \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\]","link":"/posts/3133288005.html"},{"title":"初始化Django项目一般流程(虚拟环境venv)","text":"初始化项目环境要求 vs code python3.8或更高的版本 Django最新版本(在虚拟环境中安装) 注：此项目演示在Ubuntu 20.04.3 LTS 中，在Linux系统中类似 一般过程 在某个位置，新建一个文件夹storefront，并进入文件夹内 用pipenv 安装django，前提python中有pipenv包(或者pip3 install pipenv) 在当前文件位置启动Vscode，可以看到pipfile 和 Pipfile.lock 两个文件 激活python虚拟环境，命令 pipenv shell 命令行前面多出小括号如(storefront)表示虚拟环境激活 django-admin 可以查看所有的子命令 新建一个项目storefront ，命令 django-admin startproject storefront . (此处点意思以当前为目录项目名) 本地启动django，命令 python manage.py runserver (端口默认8000，可自定义端口如python manage.py runserver 8080) 红色提示 : ”Run ‘python manage.py migrate’ to apply them.” ，表示该项目还没有进行数据库迁移绑定 http://127.0.0.1:8000/ 为django在浏览器启动本地ip，8000为默认端口，如下表示启动成功 在vscode终端terminal 启动django，先在terminal查看安装django中python解释器位置，命令 pipenv –venv ctrl + shift + p 打开 vs code常用搜索栏，输入 python: Select Interpreter ，选择对应上面位置python解释器 pipenv shell 激活python虚拟环境，命令行前面多出小括号如（storefront），表示虚拟环境激活，deactivate 表示退出虚拟环境 python manage.py runserver 启动django项目 创建项目子应用playground，命令 python manage.py startapp playground 数据库迁移 python manage.py makemigrations 生成迁移（如生成一个0001_initial.py文件） python manage.py migrate 执行迁移（根据0001_initial.py文件执行表格迁移） python manage.py migrate store 0003 执行迁移回退上一步（对应的应用store，回退到的版本0003）","link":"/posts/2752460855.html"},{"title":"内置函数(二)","text":"第一部分详见上文。。。内置函数(一) bytes()[^1] #返回新的bytes对象，是一个0&lt;= x &lt;=256之间的整数不可变序列 1234567891011&gt;&gt;&gt; a = bytes([1,2,3,4])&gt;&gt;&gt; ab'\\x01\\x02\\x03\\x04'&gt;&gt;&gt; type(a)&lt;class 'bytes'&gt;&gt;&gt;&gt; &gt;&gt;&gt; a = bytes('hello','ascii')&gt;&gt;&gt; ab'hello'&gt;&gt;&gt; type(a)&lt;class 'bytes'&gt; float() #用于将整数和字符串转换成浮点数 123456&gt;&gt;&gt; float(1)1.0&gt;&gt;&gt; float(-112.3)-112.3&gt;&gt;&gt; float('11')11.0 iter() #用来生成迭代器 1234567&gt;&gt;&gt; li = [1,2,3]&gt;&gt;&gt; for x in iter(li):... print(x)... 123 print() #用于打印输出 print(*objects, sep=‘ ’, end=‘\\n’, file=sys.stdout, flush=False ) objects – 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。 sep – 用来间隔多个对象，默认值是一个空格。 end – 用来设定以什么结尾。默认值是换行符 \\n，我们可以换成其他字符串。 file – 要写入的文件对象。 flush – 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。 12345678910111213141516171819&gt;&gt;&gt; print(1)1&gt;&gt;&gt; print(&quot;hello,world&quot;)hello,world&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = &quot;hello&quot;&gt;&gt;&gt; print(a,b)1 hello&gt;&gt;&gt; print(&quot;aa&quot;,&quot;b&quot;)aa b&gt;&gt;&gt; print(&quot;aaa&quot;&quot;bbb&quot;)aaabbb&gt;&gt;&gt; print(&quot;I&quot;,&quot;am&quot;,&quot;a&quot;,&quot;student&quot;,sep=' ') //设置间断符I am a student#--------------------------------------&gt;&gt;&gt; import time&gt;&gt;&gt; for i in range(10):... print(&quot;。&quot;,end=&quot;&quot;,flush = True)... time.sleep(0.5) //输出结果为：间断0.5s输出句号。 tuple #将可迭代对象（如列表）转化成元组 12345678910111213141516171819&gt;&gt;&gt; li = ['I','am','a','student']&gt;&gt;&gt; tuple1 = tuple(li)&gt;&gt;&gt; tuple1('I', 'am', 'a', 'student')#-------------------------------&gt;&gt;&gt; a= 'www' &gt;&gt;&gt; b = tuple(a) //将字符串转化成元组&gt;&gt;&gt; b('w', 'w', 'w')&gt;&gt;&gt; a = {'www':123,'ttt':456} //将字典的key转化成元组&gt;&gt;&gt; b = tuple(a)&gt;&gt;&gt; b('www', 'ttt')&gt;&gt;&gt; a = set('abcd') //将集合转化成元组&gt;&gt;&gt; b = tuple(a)&gt;&gt;&gt; b('a', 'd', 'b', 'c') //元组形式&gt;&gt;&gt; a{'a', 'd', 'b', 'c'} //集合形式 callable() #用于检查一个对象是否可以调用 对于函数、方法、lambda函式、类以及实现了__ all__ 方法的类实例，它的返回True 123456789101112131415161718192021222324252627&gt;&gt;&gt; callable(0)False&gt;&gt;&gt; callable('hello')False&gt;&gt;&gt; def add(a,b):... return a+b... &gt;&gt;&gt; callable(add) //函数True&gt;&gt;&gt; class A: ... def method(self):... return 0... &gt;&gt;&gt; callable(A) //类返回TrueTrue&gt;&gt;&gt; a = A() //没有实现__call__,返回 False&gt;&gt;&gt; callable(a)False&gt;&gt;&gt; class B:... def __call__(self):... return 0... &gt;&gt;&gt; callable(B)True&gt;&gt;&gt; b = B()&gt;&gt;&gt; callable(b) //实现__call__,返回 TrueTrue format() #格式化函数，可以接受不限个参数 1234567891011121314151617181920212223&gt;&gt;&gt; &quot;{} {}&quot;.format(&quot;hello&quot;,&quot;world&quot;)'hello world'&gt;&gt;&gt; &quot;{0} {1}&quot;.format(&quot;hello&quot;,&quot;world&quot;)'hello world'&gt;&gt;&gt; &quot;{1} {0} {1}&quot;.format(&quot;hello&quot;,&quot;world&quot;)'world hello world'&gt;&gt;&gt; print(&quot;网站:{name},url:{url}&quot;.format(name=&quot;博客&quot;,url=&quot;bingeone.top&quot;))网站:博客,url:bingeone.top#--------------------------------------------------&gt;&gt;&gt; site = {&quot;name&quot;:&quot;博客&quot;,&quot;url&quot;:&quot;bingeone.top&quot;}&gt;&gt;&gt; print(&quot;网站:{name},url:{url}&quot;.format(**site)) //字典调用网站:博客,url:bingeone.top&gt;&gt;&gt; li = ['博客','bingeone.top']&gt;&gt;&gt; print(&quot;网站:{0[0]},url:{0[1]}&quot;.format(li)) //列表调用，0指定li列表对象网站:博客,url:bingeone.top#---------------------------------------------------&gt;&gt;&gt; class AssignValue(object):... def __init__(self,value):... self.value = value... &gt;&gt;&gt; my_value = AssignValue(5)&gt;&gt;&gt; print(&quot;value 为:{0.value}&quot;.format(my_value))value 为:5 数字格式化 1234567891011121314151617&gt;&gt;&gt; print(&quot;{:.2f}&quot;.format(3.1415926))3.14&gt;&gt;&gt; print(&quot;{} 对应的位置是{{0}}&quot;.format(&quot;bingeone&quot;))bingeone 对应的位置是{0}#-----------进制转化-----------&gt;&gt;&gt; '{:b}'.format(11)'1011'&gt;&gt;&gt; '{:d}'.format(11)'11'&gt;&gt;&gt; '{:o}'.format(11)'13'&gt;&gt;&gt; '{:x}'.format(11)'b'&gt;&gt;&gt; '{:#x}'.format(11)'0xb'&gt;&gt;&gt; '{:#X}'.format(11)'0XB' 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:&gt;10d} 13 右对齐 (默认, 宽度为10) len() #返回对象(字符，列表，元组等)长度或者项目个数 1234567&gt;&gt;&gt; str = &quot;bingeone&quot;&gt;&gt;&gt; len(str)8&gt;&gt;&gt; &gt;&gt;&gt; ll = [1,2,3,4]&gt;&gt;&gt; len(ll)4 property() #在新式类中返回属性值 12345678910111213141516171819202122232425262728293031property.md &gt;foldedclass A(object): def __init__(self): self._x = None def getx(self): //获取x的值 return self._x def setx(self): //设置x的值 self._x = value def delx(self): //删除x的值 del self._x x = property(getx,setx,delx, &quot;I'm the 'x' property&quot;)#------------------------两种写法------------------------------class A(object): def __init__(self): self._x = None @property def x(self): //获取x的值 return self._x @x.setter def x(self): //设置x的值 self._x = value @x.deleter def x(self): //删除x的值 del self._x type() #一个参数返回对象的类型，三个参数返回新的类型对象 type(object) type(name, bases, dict) 12345678910111213141516171819&gt;&gt;&gt; type(1)&lt;class 'int'&gt;&gt;&gt;&gt; type(&quot;bingeone&quot;)&lt;class 'str'&gt;&gt;&gt;&gt; type([11,22])&lt;class 'list'&gt;&gt;&gt;&gt; type({1:'aa'})&lt;class 'dict'&gt;&gt;&gt;&gt; x = 'a'&gt;&gt;&gt; x = 1&gt;&gt;&gt; type(x) == int //判断类型True#--------------------------------&gt;&gt;&gt; class X(object):... a = 1... &gt;&gt;&gt; X = type(&quot;X&quot;, (object,), dict(a=1)) //产生一个新的类型 X&gt;&gt;&gt; X&lt;class '__main__.X'&gt; chr() #一个整数作为参数，返回一个对应的字符 123456&gt;&gt;&gt; chr(65)'A'&gt;&gt;&gt; chr(97)'a'&gt;&gt;&gt; chr(8364)'€' frozenset() #返回一个冻结的集合，冻结后集合不能再添加任何元素 123456&gt;&gt;&gt; a = frozenset(range(5))&gt;&gt;&gt; afrozenset({0, 1, 2, 3, 4}) //生成一个不可变的集合&gt;&gt;&gt; b = frozenset(&quot;bingeone&quot;)&gt;&gt;&gt; bfrozenset({'g', 'b', 'o', 'i', 'n', 'e'}) list() #用于将元组或者字符串转化成列表 12345678&gt;&gt;&gt; _tuple = (123,'baidu','www')&gt;&gt;&gt; li = list(_tuple)&gt;&gt;&gt; li[123, 'baidu', 'www']&gt;&gt;&gt; str = 'hello, world'&gt;&gt;&gt; li2 = list(str)&gt;&gt;&gt; li2['h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd'] range() #返回的是一个可迭代对象(类型是对象)，而不是列表类型 list()函数是一个对象迭代器，可以把range()返回的可迭代对象转化成一个列表 range(stop) range(start, stop, step) 123456789101112131415&gt;&gt;&gt; range(5)range(0, 5)&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]&gt;&gt;&gt; list(range(0))[]&gt;&gt;&gt; list(range(0,10,2)) //给出起点, 终点(到不了的), 步长(正整数,负整数)[0, 2, 4, 6, 8]&gt;&gt;&gt; list(range(0,-10,-2))[0, -2, -4, -6, -8]&gt;&gt;&gt; list(range(1,0))[]&gt;&gt;&gt; a = range(2,2046,2)&gt;&gt;&gt; print(a[0],a[1],a[len(a)-1])2 4 2044 vars() #函数返回对象object的属性和属性值的字典对象 123456789&gt;&gt;&gt; print(vars(A)){'__module__': '__main__', 'a': 1, '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None}&gt;&gt;&gt; a= A()&gt;&gt;&gt; print(vars(a)){}&gt;&gt;&gt; x = 1&gt;&gt;&gt; scope = vars()&gt;&gt;&gt; scope[&quot;x&quot;]1 classmethod() #对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的的cls参数，可以用来调用类的属性，类的方法，实例化对象等 1234567891011121314&gt;&gt;&gt; class A(object):... bar = 1... def func1(self): ... print('www')... @classmethod //类方法修饰... def func2(cls):... print('111') ... print(cls.bar) //调用类的属性... cls().func1() //调用类的方法... &gt;&gt;&gt; A.func2() //实例化对象1111www getatter() #返回对象的属性值 1234567891011121314151617181920&gt;&gt;&gt; class A(object):... bar = 1... &gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a,&quot;bar&quot;) //获取bar 属性1&gt;&gt;&gt; getattr(a,&quot;bar1&quot;,2) //没有bar1属性，需要设置默认值，为22#---------------------------------&gt;&gt;&gt; class B(object):... def set(self,a,b):... x = a... a = b... b = x... print(a,b)... &gt;&gt;&gt; bb = B()&gt;&gt;&gt; cc = getattr(bb,&quot;set&quot;)&gt;&gt;&gt; cc(a=1,b=2)2 1 locals() #以字典的形式返回当前位置的全部局部变量 123456&gt;&gt;&gt; def A(arg): //两个局部变量：arg z... z= 11... print(locals())... &gt;&gt;&gt; A(22){'arg': 22, 'z': 11} //返回一个名字/值对的字典 repr() #将对象转化为供解释器读取的形式 123456&gt;&gt;&gt; a = 'aabbcc'&gt;&gt;&gt; repr(a)&quot;'aabbcc'&quot;&gt;&gt;&gt; li = [1,2,3,4]&gt;&gt;&gt; repr(li)'[1, 2, 3, 4]' zip() #将可迭代的对象作为参数，将对象对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样的作用可以节约内存 12345678910111213141516&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) //返回对象&gt;&gt;&gt; zipped&lt;zip object at 0x7fa2f71d36c0&gt; //对象地址&gt;&gt;&gt; list(zipped) //罗列对象成列表形式[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) //元素的个数与最短的列表一样[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) //与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6] compile() #将一个字符串编译为字节代码 compile(source, filename, mode[, flags[,dont_inherit]]) source – 字符串或者AST（Abstract Syntax Trees）对象。。 filename – 代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。 mode – 指定编译代码的种类。可以指定为 exec, eval, single。 flags – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。。 flags和dont_inherit是用来控制编译源码时的标志 123456789101112131415161718&gt;&gt;&gt; str = &quot;for i in range(1,10): print(i)&quot;&gt;&gt;&gt; c = compile(str,&quot;&quot;,&quot;exec&quot;) //编译为字节代码对象&gt;&gt;&gt; c&lt;code object &lt;module&gt; at 0x7fa2f71ed5b0, file &quot;&quot;, line 1&gt;&gt;&gt;&gt; exec(c)123456789&gt;&gt;&gt; str = &quot;3*4+5&quot;&gt;&gt;&gt; a = compile(str,&quot;&quot;,&quot;eval&quot;)&gt;&gt;&gt; eval(a)17 globals() #以字典的形式返回当前位置的全部全局变量 123&gt;&gt;&gt; a = 123&gt;&gt;&gt; print(globals()){'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'a': 123} map() #根据提供的函数对序列做映射 123456789&gt;&gt;&gt; def square(x): ... return x**2 //返回x 的平方... &gt;&gt;&gt; map(square, [1,2,3,4]) //计算列表中各元素的平方&lt;map object at 0x7fa4ad1d2f10&gt; //返回迭代器&gt;&gt;&gt; list(map(square, [1,2,3,4])) //转化成列表[1, 4, 9, 16]&gt;&gt;&gt; list(map(lambda x:x**2, [1,2,3,4])) //使用 lambda 匿名函数[1, 4, 9, 16] reversed() #返回一个反转的迭代器 123456789101112131415&gt;&gt;&gt; seqString = '12345'&gt;&gt;&gt; print(list(reversed(seqString)))['5', '4', '3', '2', '1']&gt;&gt;&gt; seqTuple = (1,2,3,4)&gt;&gt;&gt; print(list(reversed(seqTuple)))[4, 3, 2, 1]&gt;&gt;&gt; seqRange = range(1,5)&gt;&gt;&gt; print(list(reversed(seqRange)))[4, 3, 2, 1]&gt;&gt;&gt; seqList = [1,2,3,4]&gt;&gt;&gt; print(list(reversed(seqList)))[4, 3, 2, 1] __import__() #用于动态加载类和函数 12&gt;&gt;&gt; import sys&gt;&gt;&gt; __import__('p01.py') # 导入 p01.py 模块 complex() #用于创建一个值为renl + imag*j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数 12345678&gt;&gt;&gt; complex(1, 2)(1+2j)&gt;&gt;&gt; complex(1) //数字(1+0j)&gt;&gt;&gt; complex(&quot;1&quot;) //字符串(1+0j)&gt;&gt;&gt; complex(&quot;1+2j&quot;) //这个地方在&quot;+&quot;号两边不能有空格，也就是不能写成&quot;1 + 2j&quot;，应该是&quot;1+2j&quot;，否则会报错(1+2j) hasattr() #用于判断对象是否包含对应的属性 12345678910&gt;&gt;&gt; class Coordinate:... x = 10... y = -2... z = 0... &gt;&gt;&gt; p = Coordinate()&gt;&gt;&gt; print(hasattr(p,&quot;x&quot;))True&gt;&gt;&gt; print(hasattr(p,&quot;no&quot;)) //没有对应的属性False max() #返回给定的最大值，参数可以为序列 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; print(&quot;max(80,30,50,75):&quot;,max(80,30,50,75))max(80,30,50,75): 80#----------------------------------------------#max(x, y[, z...]):Number|Sequence 入参类型不能混入（要么全Number(int|float|complex|bool），要么全序列）。#单序列入参，返回序列中最大的一个数值多序列入参, 按索引顺序，逐一对比各序列的当前索引位的 “值”，直到遇见最大值立即停止对比，并返回最大值所在的序列（也就是说，多序列入参，返回值依旧是一个序列，而不是数值）&gt;&gt;&gt; max(0,True) //bool True&gt;&gt;&gt; max([1,2,3]) //单序列3&gt;&gt;&gt; max(1,2,4)4&gt;&gt;&gt; max(-1,-0.5,-0)0&gt;&gt;&gt; max((1,2,3))3&gt;&gt;&gt; max([2,4],[3,6]) //多序列，按索引位置比较[3, 6]&gt;&gt;&gt; max([2,4],[1,5])[2, 4]&gt;&gt;&gt; max([2,4],[1,5],[3,1])[3, 1]&gt;&gt;&gt; max((1,2,3),(3,3,0))(3, 3, 0)&gt;&gt;&gt; max((1,-1,0),(True,False,0)) //bool，多序列(True, False, 0)&gt;&gt;&gt; max((1,-1,0),(True,False,2,0),(1,0,0,2))(True, False, 2, 0)&gt;&gt;&gt; max((1,-1,0),(True,),(1,))(1, -1, 0)&gt;&gt;&gt; max((-1,-1,0),(True,),(1,))(True,)&gt;&gt;&gt; max([1,2,3],3,4) //number 和 序列混杂报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: '&gt;' not supported between instances of 'int' and 'list'&gt;&gt;&gt; max((1,2,3),[1,2,3]) //不同类型序列，报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: '&gt;' not supported between instances of 'list' and 'tuple' round() #返回浮点数x的四舍五入，准确的说保留到离上一位更近的一端（四舍六入），精度要求较高的，一般不使用该函数 123456789101112131415&gt;&gt;&gt; print(&quot;round(70.23456):&quot;,round(70.23456))round(70.23456): 70&gt;&gt;&gt; print(&quot;round(56.659,1):&quot;,round(56.659,1))round(56.659,1): 56.7&gt;&gt;&gt; print(&quot;round(80.264,2):&quot;,round(80.264,2))round(80.264,2): 80.26&gt;&gt;&gt; print(&quot;round(100.000056,3):&quot;,round(100.000056,3))round(100.000056,3): 100.0&gt;&gt;&gt; print(&quot;round(-100.000056,3):&quot;,round(-100.000056,3))round(-100.000056,3): -100.0&gt;&gt;&gt; print(&quot;round(2.675,2):&quot;,round(2.675,2)) round(2.675,2): 2.67# 按我们的想法返回结果应该是 2.68，可结果却是 2.67，为什么？# 这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串 1 和 0 后可能是无限位数的，机器已经做出了截断处理。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离 2.67 要更近一点点，所以保留两位小数时就近似到了 2.67。 delattr() #用于删除函数属性 1234567891011121314151617181920212223&gt;&gt;&gt; class Coordinate:... x =10... y = 1... z = 0... &gt;&gt;&gt; p = Coordinate()&gt;&gt;&gt; print(&quot;x=:&quot;,p.x)x=: 10&gt;&gt;&gt; print(&quot;y=:&quot;,p.y)y=: 1&gt;&gt;&gt; print(&quot;z=:&quot;,p.z)z=: 0&gt;&gt;&gt; &gt;&gt;&gt; delattr(Coordinate,&quot;z&quot;) //删除类中 z的属性&gt;&gt;&gt; &gt;&gt;&gt; print(&quot;x=:&quot;,p.x)x=: 10&gt;&gt;&gt; print(&quot;y=:&quot;,p.y)y=: 1&gt;&gt;&gt; print(&quot;z=:&quot;,p.z) //类中没有该属性，报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: 'Coordinate' object has no attribute 'z' hash() #返回对象的哈希值 12345678&gt;&gt;&gt; hash('test')3938127732211961192&gt;&gt;&gt; hash(1)1&gt;&gt;&gt; hash(str([1,2,3]))-8986991832632495888&gt;&gt;&gt; hash(str(sorted({'1':1})))341477958600190998 memoryview() #返回给定参数的内存查看对象（memory view） 所谓内存查看对象，是指支持缓冲协议的数据进行包装，在不需要复制对象基础上允许python代码访问 123456789&gt;&gt;&gt; a = memoryview(bytearray(&quot;abcefg&quot;,&quot;utf-8&quot;))&gt;&gt;&gt; print(a[0]) //索引 0位的asii码97&gt;&gt;&gt; print(a[-1])103&gt;&gt;&gt; print(a[1:4])&lt;memory at 0x7fa845b14580&gt;&gt;&gt;&gt; print(a[1:4].tobytes())b'bce' toBytes()方法是将参数使用UTF-8的编码格式转换成byte[],getBytes()是用读取file.encoding的编码格式,然后用读取的格式进行转换, set() #创建一个无序不重复元素集，可以进行关系测试，删除重复数据，还可以计算交集，差集，并集等 交集 &amp; : x&amp;y，返回一个新的集合，包括同时在集合 x 和y中的共同元素。 并集 | : x|y，返回一个新的集合，包括集合 x 和 y 中所有元素。 差集 - : x-y，返回一个新的集合,包括在集合 x 中但不在集合 y 中的元素。 补集 ^ : x^y，返回一个新的集合，包括集合 x 和 y 的非共同元素。 1234567891011121314&gt;&gt;&gt; x = set('alibaba')&gt;&gt;&gt; y = set('google')&gt;&gt;&gt; x,y({'i', 'a', 'l', 'b'}, {'e', 'o', 'l', 'g'})&gt;&gt;&gt; x &amp; y{'l'}&gt;&gt;&gt; x | y{'o', 'a', 'i', 'l', 'e', 'g', 'b'}&gt;&gt;&gt; x - y{'i', 'a', 'b'}&gt;&gt;&gt; x ^ y{'o', 'a', 'b', 'i', 'e', 'g'}&gt;&gt;&gt; y ^ x{'o', 'a', 'i', 'e', 'g', 'b'} ​ 以上总共68个python内置函数，学习资料来自菜鸟教程 内置函数 abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() delattr() hash() memoryview() set()","link":"/posts/1555555841.html"},{"title":"视频页测试","text":"视频嵌入md演示 外部视频链接，引入markedown进行样式包装演示，链接封装还有待优化。 video >folded123&lt;div style=&quot;position:relative; padding-bottom:75%; width:100%; height:0&quot;&gt; &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=289911559&amp;bvid=BV1Af4y147Jv&amp;cid=319275725&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position:absolute; height: 100%; width: 100%;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 方式一 方式二","link":"/posts/3282361534.html"}],"tags":[{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Typora","slug":"Typora","link":"/tags/Typora/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"程序","slug":"程序","link":"/tags/%E7%A8%8B%E5%BA%8F/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"django","slug":"django","link":"/tags/django/"},{"name":"B站","slug":"B站","link":"/tags/B%E7%AB%99/"},{"name":"python3","slug":"python3","link":"/tags/python3/"}],"categories":[{"name":"软件","slug":"软件","link":"/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"fluent_python","slug":"fluent-python","link":"/categories/fluent-python/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"视频","slug":"视频","link":"/categories/%E8%A7%86%E9%A2%91/"}]}