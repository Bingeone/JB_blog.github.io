{"pages":[{"title":"","text":"唠一唠 ↑↑↑ 点击“唠一唠”试试看！ function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/?c=b', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } }); } ==About me== 简介 爱瞎折腾 喜欢足球运动 非码农业余选手 ==博客简述== 基于Hexo博客系统采用Icarus主题 借鉴其它优秀博主博客改造 本博客主要用于学习记录分享 。。。暂时就这样，后续更新！","link":"/about/index.html"},{"title":"","text":"友链申请须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo头像。 加载中... 本站友链添加信息需求 头像链接: “https://sm.ms/image/E1WNvLfnl47MzAc&quot;站名: “Bingeone”简述: “生命在于折腾，长寿源于静止”网址: “https://bingeone.top/&quot;","link":"/friends/index.html"},{"title":"","text":"看一看，说一说 欢迎畅所欲言，留下宝贵意见","link":"/talking/index.html"},{"title":"bookmark","text":"常用 在线免费图床 在线PhotoShop编辑器 图片裁剪尺寸缩放 在线配色工具 jQuery在线文档 Flutter 中国官网 JSON在线解析 在线webp转换 JPG/PNG压缩 知识星球 Git-book 统计SEO Google统计 百度统计 51LA统计 百度站长平台 百度指数 今日头条站长平台 测试网速 网站测速 SSL 免费证书 在线工具 PP直连 视频地址解析器 视频转GIF 图片裁剪尺寸缩放 图片添加水印文字 JPG/PNG压缩 在线配色工具 在线webp转换 PDF转换加密工具 短链接生成 在线工具【1】 在线文字转语音 在线工具大全【2】 在线工具大全【3】 聚合免费图床 FireFox在线分享 图标工厂 视频压缩 视频图床 插件和接口 天气插件 静态资源公共库 360 静态资源 CDN 库 Font Awesome 图标库 蓝奏云-网盘 HTML5 2D 引擎 免费 API接口查询 公共组件 v-charts图表 chartjs图表 Echarts图表 Zdog--3D组件 一个加载中svg图标库 资源下载类 潘多拉盒子 Mac精品应用下载 计算机图书-PDF itbook-pdf技术书籍下载 壁纸下载 Kindle书籍下载 Gradle下载 装机必备 压缩解压-7zip（Win） 截图工具-ShareX（Win） 牛逼编辑器-VSCode（Win + Mac） PDF阅读器（Win） 腾讯桌面整理（Win） Alfred 效率神器（Mac） 翻译插件-沙拉查词（Chrome） AdBlock 广告拦截（Chrome） Google 上网助手（Chrome） Chrome 清理大师 终端 Terminal 美化（Mac） eZip 压缩工具（Mac） Dash 程序员工具（Mac） Snipaste 截图贴图（Win + Mac） PotPlayer 视频播放器（Win） IINA 视频播放器（Mac） TodoList（Mac + Win） Paste 便捷剪贴板（Mac） Mac 软件汇总大全 TeamViewer远程协助 腾讯柠檬清理（Mac） 开发工具 Modbus-RTU PC版（Win） 串口调试助手-PC版（Win） 串口调试助手-Android版 Android Studio 最新版本（Win + Mac） Android 模拟器 （Mac+Win） 虚拟串口工具（Win） JDK 下载 Ubuntu 桌面版下载 Xmanager 终端模拟 Android 屏幕镜像 VS Code 插件 Code Runner Markdown PDF Remote - SSH GitLens — Git supercharged HTML Boilerplate Neo Vim 官网和文档 Dart 中文文档 Google中国官网 Android系统源码 Android 官方系统源码 Google优酷频道 Modbus 资料汇总大全 stylus pug Flow Babel ESLint Linux命令搜索工具 Linux命令大全（中文） bulma ECMAScript 6 入门 CommonJS规范 MDN Web Docs jQuery在线文档 CSS 参考手册 设计资源 花瓣 站酷 UI中国 Jenny Le's Design 图片编辑海报制作 色盘配色 Gif动图一站式 蓝湖 摄影和壁纸 Photoshop高手之路 1PX 500PX 影视娱乐 清新范-高清电影 91美剧网 电视剧下载 BT 电视剧在线看 达达兔-电影-电视 学习和资料 Flutter 实战（书籍） 微机原理与接口技术 Python最佳实践指南 adb 命令大全 Android官方博客 Android性能优化 美团技术团队 英文资料中文翻译 Android资料网站 各种开发资源大集合汇总 Android 操作系统架构开篇 GitHub 排行榜 关于NB-IoT Modbus资料汇总 Android加入购物车效果 C语言推荐书籍 Android实现相机圆形","link":"/bookmark/index.html"}],"posts":[{"title":"Linux 基础知识","text":"ubuntu 使用技巧 mkdir的技巧 1234#创建 ～/a/b/cmkdir -p ~/a/b/c/#创建多个文件夹mkdir a b c touch 1234#创建文件touch a.txt#在绝对路径中创建文件touch /home/robot/myfile.txt rm 删除 12345#删除文件rm a.txt#删除文件夹rm -rf a或者 trash-put a #将文件移动到回收站 需安装trash-cli cp 复制 12#复制文件夹到指定位置cp -r myfile/ /home/robot/ mv 移动或重命名文件 12345#移动文件夹到指定位置mv myfile /home/robot#重命名文件夹mv myfile myfile01 man 查看linux命令手册 1234#查看ls手册man ls #查看帮助reboot help cd reboot 重启linux系统 shutdown 立即关机 12# 立即关机shotdown -h now ctrl + - 缩小命令行字体大小，ctrl + shift + + 放大 ctrl + alt + T 在桌面快速启动终端 ls -lah 查看当前目录下所有文件详情 time 加执行文件，可以计时运行文件消耗时间 查看ubuntu 挂载详情 df -h 切换用户：su root 更新linux环境：source /etc/environment 软链接如：sudo ln -fs /usr/bin/npm /usr/local/bin/npm linux 端口占用查看和关闭 1234567891011121314151617181920#查看已经连接的服务端口（ESTABLISHED）netstat -a#查看所有的服务端口（LISTEN，ESTABLISHED）netstat -ap#查看指定端口，可以结合grep命令：netstat -ap | grep 8000#还可以使用lsof命令：lsof -i:4000#关闭正在使用端口的程序，用kill + 对应的pidkill -9 pid(号) pip 下载镜像源 123456789#使用方法：pip install requsets -i https://pypi.tuna.tsinghua.edu.cn/simple/ Scipy#镜像源列表：https://mirrors.aliyun.com/pypi/simple/ //阿里https://pypi.tuna.tsinghua.edu.cn/simple/ //清华https://pypi.douban.com/ //豆瓣https://pypi.hustunique.com/ //华中理工大学https://pypi.sdutlinux.org/ //山东理工大学https://pypi.mirrors.ustc.edu.cn/ //中国科学技术大学 ubuntu 系统命令行设置投屏显示 12345678# 使用单显示屏---关闭笔记电脑屏幕（即主屏 LVDS-1不同笔记本可能不一样有eDP-1端口等）xrandr --output LVDS-1 --off #扩展屏幕模式xrandr --output HDMI-1 --right-of LVDS-1 --auto# 切回主屏命令（或者直接合上笔记本再打开）xrandr --output LVDS-1 --auto ​ Ubuntu系统笔记本投屏显示器方法—参考 在linux中制作desktop快捷链接方式 12345678910111213141516171819202122#新建一个连接程序vim typora.desktop[DesktopEntry]Name=Typora#打开软件路径Exec=/opt/Typora/bin/Typora-linux-x64/Typora #类型Type=Application #图标位置Icon=opt/Typora/bin/Typora-linux-x64/resources/assets/iconicon_512x512.png #将程序拷贝到目标地址cp typora.desktop /usr/share/applications/ #将可执行的程序链接到终端的可执行命令，即配置环境ln -s /home/robot/software/Typora/bin/Typora-linux-x64/Typora /usr/sbin/#更改可执行权限(在./Typora文件中)chown root.rootchrome-sandboxchmod 755 chrome-sandbox Linux 系统目录结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172731. / ：根 每一个文件和目录从根目录开始。只有root用户具有该目录下的写权限。请注意，/root是root用户的主目录，这与/不一样2. /bin ：用户二进制文件包含二进制可执行文件。在单用户模式下，你需要使用的常见Linux命令都位于此目录下。系统的所有用户使用的命令都设在这里。例如：ps、ls、ping、grep、cp3. /sbin ：系统二进制文件就像/bin，/sbin同样也包含二进制可执行文件。但是，在这个目录下的linux命令通常由系统管理员使用，对系统进行维护。例如：iptables、reboot、fdisk、ifconfig、swapon命令4. /etc ：配置文件包含所有程序所需的配置文件。也包含了用于启动/停止单个程序的启动和关闭shell脚本。例如：/etc/resolv.conf、/etc/logrotate.confhosts：设备名称（或域名）到ip地址的解析，相当于本地存在的dns功能。5. /dev ：设备文件包含设备文件。这些包括终端设备、USB或连接到系统的任何设备。例如：/dev/tty1、/dev/usbmon06. /proc ：进程信息包含系统进程的相关信息。这是一个虚拟的文件系统，包含有关正在运行的进程的信息。例如：/proc/{pid}目录中包含的与特定pid相关的信息。这是一个虚拟的文件系统，系统资源以文本信息形式存在。例如：/proc/uptime7. /var ：变量文件var代表变量文件。这个目录下可以找到内容可能增长的文件。这包括 - 系统日志文件（/var/log）;包和数据库文件（/var/lib）;电子邮件（/var/mail）;打印队列（/var/spool）;锁文件（/var/lock）;多次重新启动需要的临时文件（/var/tmp）;8. /tem ：临时文件包含系统和用户创建的临时文件。当系统重新启动时，这个目录下的文件都将被删除。9. /usr ：系统应用程序包含二进制文件、库文件、文档和二级程序的源代码。/usr/bin中包含用户程序的二进制文件。如果你在/bin中找不到用户二进制文件，到/usr/bin目录看看。例如：at、awk、cc、less、scp。/usr/sbin中包含系统管理员的二进制文件。如果你在/sbin中找不到系统二进制文件，到/usr/sbin目录看看。例如：atd、cron、sshd、useradd、userdel。/usr/lib中包含了/usr/bin和/usr/sbin用到的库。/usr/local中包含了从源安装的用户程序。例如，当你从源安装Apache，它会在/usr/local/apache2中。10. /home ：HOME 目录所有用户用home目录来存储他们的个人档案。例如：/home/robot/11. /boot ：引导加载程序文件包含引导加载程序相关的文件。内核的initrd、vmlinux、grub文件位于/boot下。例如：initrd.img-2.6.32-24-generic、vmlinuz-2.6.32-24-generic12. /lib ：系统库包含支持位于/bin和/sbin下的二进制文件的库文件.库文件名为 ld或lib.so.*例如：ld-2.11.1.so，libncurses.so.5.713. /opt代表可选的。包含从个别厂商的附加应用程序。附加应用程序应该安装在/opt/或者/opt/的子目录下。14 /mnt ：挂载目录临时安装目录，系统管理员可以挂载文件系统。15 /media ：可移动媒体设备用于挂载可移动设备的临时目录。举例来说，挂载CD-ROM的/media/cdrom，挂载软盘驱动器的/media/floppy;16 /srv ：服务数据srv代表服务。包含服务器特定服务相关的数据。例如，/srv/cvs包含cvs相关的数据。 SSH 协议 123456# 在 ~/.bashrc 文件中配置如下命令：alias name01 = &quot;ssh root@192.168.17.2&quot;注：在终端中输入 name01相当于ssh root@192.168.17.2,其中alias是别名执行过程中需要输入远程许可密码，可以使用ssh-keygen生成本地秘钥，然后将该秘钥复制到远程服务器的authorized_keys文件（在 ~/.ssh位置），内容追加方式添加。 开启ssh远程登陆—在ubuntu上配置流程 123456789101112131415161718192021222324252627282930313233# 下载 opnessh-serversudo apt update //更新源文件sudo apt upgrate //更新软件，升级包文件sudo apt install openssh-server //下载ssh第三包# 激活和参看ssh状态sudo systemctl enable ssh //激活sudo systemctl start ssh //启动sudo systemctl status ssh //查看ssh网络状态#设置firewall允许ssh端口(默认port 22)sudo ufw allow ssh //sudo ufw allow|deny [service] 开启或禁用某个服务sudo ufw enable // 重启firewallsudo ufw status#查看本机网络ip及用户名ifconfigwhoami#在其他平台上通过远程连接工具(xshell等)登陆ubuntussh username@ip //需要输入登陆ubuntu该用户的密码#-------------------------其他操作-------------------------#更改端口号sudo vim /etc/ssh/sshd_config //将port 22 更改成1024之后的端口如(port 2222)，取消#号注释#重启sshsudo /etc/init.d/ssh restart sudo service ssh restart#查看服务状态ps ax | grep sshsudo netstat -ant // 查看与外部连接端口情况#用root账号密码远程登陆需要设置sudo password root (密码) //重置密码sudo vim /etc/ssh/sshd_config //取消root登陆限制，更改成PermitRootLogin yessudo service ssh restart //重启 ubuntu 安装、卸载清除 12345678910111213141516171819202122232425262728# 安装软件sudo apt-get install softname# 卸载软件sudo apt-get remove softname# 卸载清理配置sudo apt-get remove -purge softname# 更新软件信息数据库sudo apt-get update# 系统升级sudo apt-get upgrade# 搜索软件包sudo apt-cache search softname#--------deb 软件的安装卸载--------# 安装deb软件包dpkg -i xxx.deb# 删除deb软件包dpkg -r xxx.deb# 删除deb软件包及配置文件dpkg -r -purge xxx.deb# 查看软件包信息dpkg -info xxx.deb# 查看文件拷贝详情dpkg -L xxx.deb# 查看系统中安装的deb包详情dpkg -l# 重新配置软件包dpkg -reconfigure xxx 删除缓存 123456sudo apt-get autoclean # 清理旧版本的软件缓存sudo apt-get clean # 清理所有软件缓存sudo apt-get autoremove # 删除系统不再使用的孤立软件#--------------------------------# 卸载：tracker(此应用与文件管理器关联)# 这个东西一般我只要安装ubuntu就会第一删掉tracker 他不仅会产生大量的cache文件而且还会影响开机速度。所以在新得利里面删掉就行。 删除多余内核 12345678# 当前Ubuntu系统使用的内核uname -a# 查看所有内核dpkg --get-selections | grep linux# 删除旧内核，注意一般选内核号较小的sudo apt-get remove linux-image-xxxxx-genericsudo apt-get remove linux-headers-xxxxxsudo apt-get remove linux-headers-xxxxx-generic .tar.gz文件解压缩命令—linux文件 1234# 压缩命令tar -zcvf 压缩文件名.tar.gz# 解压缩tar -zxvf 文件名.tar.gz ubuntu中Python虚拟环境 1234567#------------pipenv---------------# 安装 pip3sudo apt install python3-pip# 安装 pipenvpip install pipenv# 全局安装 pipenvsudo -H pip install -U pipenv linux系统架构 linux系统架构：AMD、ARM、x86、x86_64等 公认i386为32位系统，也就是x86 ARM架构是一个32位精简指令集（RISC）处理器架构，主要应用在智能手机和平板电脑 x86_64,x64,AMD64基本上是同一个东西，市面上的intel/amd的桌面级CPU基本上都是x86_64 1234567891011# 查看内核版本uname -auname -r# 查看linux版本信息cat /etc/issue# 查看linux是64为还是32位file /bin/ls# 查看系统的架构archdpkg --print-architecturefile /lib/systemd/systemd cpu架构叫法区别x86\\x86_64\\amd64","link":"/posts/5655611541.html"},{"title":"Git版本控制精简版","text":"Git是一种强大高效VCS(version control system版本控制系统)，能够实现项目文件过程的实时监控。git使用方式与其他版本控制系统（如CVS、Subversion、Perfoce）类似，但前后者之间区别的：git保存处理数据，对当时项目状态采用创建一种快照的索引方式；后者处理存储信息是基于文件随时间累积差异。 Git的特点 直接记录快照，而非差异比较 近乎所有操作都是本地执行 Git 保证完整性 Git 一般只添加数据 三种状态：已提交（committed）、已修改（modified） 和 已暂存（staged） 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 已提交表示数据已经安全地保存在本地数据库中 三个阶段：工作区、暂存区以及 Git 目录 工作区（操作文件的目录文件）是对项目的某个版本独立提取出来的内容 暂存区是一个文件（过度文件），保存了下次提交的文件列表信息，一般在 Git 仓库目录中 Git 仓库目录（.git directory目录文件）是 Git 用来保存项目的元数据和对象数据库的地方 Git安装windows下: git官网下载 ubuntu下: linux各个发行版安装Git命令 12345# 更新安装源sudo apt-get update# 安装gitsudo apt-get install git Git 使用前配置 git config –global user.name 提交人姓名 git config –global user.email 提交人邮箱 git config –list 查看配置信息 如需要修改，重复上述命令即可 常用操作命令 git init 初始化git仓库 git status 查看过渡区的文件状况 git add 文件名 提交文件到过渡区 git commit -m ‘提交注释’正式提交到git的本地仓库 git log 查看提交的记录 git diff HEAD – 文件名 查看此文件变动信息 git restore 文件名 可以从git本地仓库中下载文件到工作目录 git reset HEAD 文件名 从缓存取撤回文件 git log –pretty=oneline 查看提交 版本信息在一行显示 git log –oneline 每行显示一条commit git reset –hard HEAD~3 表示回退3个版本（^^^三个版本，可以回退删除的文件） git reset –hard 版本信息标识 可以回退到指定的版本 git reflog 可以查看所有的提交信息，包括之前回退后没有标识信息的版本 git ls-files 查看git本地仓库的文件信息 git checkout – 文件名 可以从git本地仓库中下载文件到工作目录（工作目录文件可以直接删除） git checkout 分支名 切换分支（或 git switch 分支名） git checkout -b 分支名 创建分支并切换到该分支上 git checkout -m|-M 重命名分支 git branch 分支名 创建分支 git branch 查看分支列 git merge 分支名 将该分支上的文件合并到master 上（在切换到master的前提下） git branch -d 分支名 将该分支删除 git rm 文件名 可以删除git本地仓库和工作目录的文件 git add 文件名 可以删除已存在的文件（没有就是添加） 主干和分支冲突（conflict）解决 冲突出现：通道上会显示主干和分支两个名字 （同一个文件同一行内容不同，产生冲突） 解决方式：需要在主干（main）上对应的文件进行冲突内容的修改，并再一次提交（commit），这时通道就会切回一个支干，（注：分支上的对应文件的内容不会相应修改，只能以主干上的为准，只是解决操作显示错误问题，不能够同时修改主干和分支的文件内容） git log –graph –pretty=oneline 查看冲突线路图 多人协同冲突 冲突出现：（同一个文件同一行内容不同，产生冲突） push远程时会报错冲突 解决方式： 需要将内容pull下来，然后查看相关冲突的文档内容并修改，再次commit，并push就可以 一般操作先从远程pull，修改不同内容后再commit 标签操作（tag：相当给当前打标签文件进行压缩保存包，可以直接下载） git tag 查看所有带标签的号 git tag 标签号 对当前支干通道打标签 git tag 标签号 版本标识 对某个文件打标签 git tag -a 标签号 -m ‘注释内容’ 版本标识 对某个文件打标签，并加注释内容 git push origin –tags 推送所有没有被推送的标签 git push origin :refs/tags/v1.0(标签号) 删除远程标签 git tag -d v1.0（标签号） 删除本地标签 与Github关联方法 方式一：本地先建好仓库，在github上再建仓库 123456789101112131415ssh-keygen –t rsa(生成秘钥key，用于关联远程仓库，如github)，生成了id_rsa和id_rsa.pub将生成id_rsa.pub用记事本或者其他软件打开，将其全部复制到github上再点击New SSH keyTile 是填写SSH key的标题名字Key 是id_rsa.pub复制的文件数据内容，测试是否关联成功：ssh -T git@github.com 对于 oschina 的 “码云” ，执行 ssh -T git@git.oschina.net 对于 coding 的 “码市” ，执行 ssh -T git@git.coding.netgit branch -a 查看所有分支（远程和本地）git push origin dev1 推送本地某个分支到远程git push origin :dev1 删除远程某个分子git fetch 在github上手动添加分支，需要这个命令刷新git checkout -b dev2 origin/dev2 将远程新建的分支下载到本地，并切换到该分支上 方式二：在github上先建仓库，再将其git clone下来（也能关联远程） 操作注意事项 一般在分支上提交修改文件，然后git switch main 切换到主分支上，再推送到远程仓库不能在要删除的分支上使用 git branch -d 删除该分支 12345678910111213141516171819202122232425262728#git status中文乱码问题 git config --global core.quotepath false#git log 乱码问题 git config --global i18n.commitencoding utf-8 git config --global i18n.logoutputencoding utf-8#删除未被追踪（tracked） git clean -xf#区域关系： workspace即工作区，也就是本地计算机 staging 即版本库中的stage，暂存区 local repository 即版本库中的master（main），也称本地仓库 Remote repository 则是远程仓库#用git config命令查看配置文件： 命令参数 –list, 简写 -l 格式：git config -l 查看仓库级的config，即.git/.config，命令：git config --local -l 查看全局级的config，即C:\\Users\\.gitconfig，命令：git config --global -l 查看系统级的config，即D:\\Program Files\\Git\\etc\\gitconfig，命令：git config --system -l#用git config命令编辑配置文件（一般在电脑所对应的文件修改，即上述） 命令参数 –edit, 简写 -e 格式：git config [–local|–global|–system] -e 查看仓库级的config，即.git/.config，命令：git config --local -e，git config -e默认是#编辑仓库级的配置文件。 查看全局级的config，即C:\\Users\\zuoyu.ht\\.gitconfig，命令：git config --global -e 查看系统级的config，即D:\\Program Files\\Git\\etc\\gitconfig，命令：git config --system -e 学习资料 git学习手册下载 GUI可视化工具： TortoiseGit(小乌龟) Source Tree","link":"/posts/2489357851.html"},{"title":"Vim常用快捷操作","text":"Vim是从 vi 单纯的文字处理软件发展成强大的程序开发工具，具备代码补完、编译及错误跳转等方便编程的功能，并且支持强大的第三方插件。 Vim安装教程windows下: 从官网下载EXE安装包 直接点击安装安装包，一直next安装，过程中可以指定安装位置 配置环境变量(通用配置)，我的电脑&gt;属性&gt;高级系统设置&gt;高级&gt;环境变量&gt;系统变量&gt;Path&gt;新建&gt;vim.exe文件位置(自定义安装位置) windows安装图文教程 windows环境配置图文教程 ubuntu下: 12345678# 更新安装源sudo apt-get update# 安装vimsudo apt-get install vim# vim的配置文件sudo vim /etc/vim/vimrc Vim 常用快捷操作 Vim 三种模式 命令模式(Command mode)：启动时默认状态，可以执行移动、复制、删除等操作，不可编辑 插入模式(Insert mode)：按 i 进入编辑模式，正常文本编辑 底行模式(Last line mode)：执行保存、退出以及其他的一些功能。按下Shift+:即可进入底行模式 保存文件并退出—— :wq! # 感叹号 退出不保存—— :q 模式切换——— esc Vim 插件下载Vim Awesome官网（演示：插件管理器Vundle.vim ,不同管理器下载、卸载方式有差异） 在命令模式下，输入: PluginInstall 下载插件(前提：在./vimrc 文件中添加插件名称) 输入：PluginClean 卸载插件(前提：在./vimrc 文件中删除插件或注释) 常用插件 youcompleteme—-代码补全 NEDRTree——树状目录结构 功能(命令模式下) 快捷键 功能(命令模式下) 快捷键 上下左右移动 h/j/k/l(方向键) 插入(编辑模式) i 删除/剪切当前行 dd 按词向后移动 w 复制当前行 yy 按词向前移动 b 粘贴(向下) p 选中当前行 V 撤销 u 上一页 ctrl + b 反撤销 ctrl + r 下一页 ctrl + f 回到首端 gg / home 重复上一次命令 ` 回到尾端 G / end 删除当前字符 x 全局替换 :% s/要替内容/内容/g 在查找str选中下，向下移动光标定位到str n 局部替换 :开始行,结束行s/要替换内容/内容 在查找str选中下，向上移动光标定位到str N 定位指定行 数字+gg 搜索内容 :/内容 自动补全 ctrl + n (Vim默认) 删除当前行 cc Vim键盘快捷键图示链接 ctrl + n 自动补全 批量注释 1234567891011# 在 5-15 行添加 // 注释:5,15s#^#//#g# 在 5-15 行取消 // 注释:5,15s#^//##g# 在 5-15 行添加 # 注释:5,15s/^/#/g# 在 5-15 行取消 # 注释:5,15s/^#//g Linux常用文本工具 vi/vim gedit nano 常用编辑命令 命令 用途 echo 屏幕打印与文本输出 cat 合并文件或查看文件内容 tail 显示文件内容的尾部 grep 文本过滤工具 echo “hello” # 打印文本内容 #将内容写入txt文件中 echo “hello,world”&gt;hello.txt","link":"/posts/3517918973.html"},{"title":"python装饰器","text":"装饰器好比一种语法糖，实现优化语言、增强被修饰对象的行为。装饰器是可调用的对象，其参数是另一个函数(被装饰的函数)；装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象^1^。装饰器两大特性： 能把被装饰的函数替换成其他函数 装饰器在加载模块时立即执行 装饰器在python装饰方式特点 通用装饰器装饰函数 123456789101112131415161718192021222324252627282930313233def func(functionName): def func_in(*args, **kwargs): ret = functionName(*args, **kwargs) return ret return func_in@funcdef test(): print(&quot;---test---&quot;) return &quot;haha&quot;@funcdef test2(): print(&quot;---test2---&quot;) @funcdef test3(a): print(&quot;---test---a=%d---&quot; %a)ret = test()print(&quot;test return value is %s&quot; %ret)a = test2()print(&quot;test2 return value is %s&quot;%a) # 没有返回值， 返回Nonetest3(11)#-------------结果-------------------test---test return value is haha---test2---test2 return value is None---test---a=11--- 带参数的装饰器 12345678910111213141516171819202122232425262728def func_arg(arg): def func(functionName): def func_in(): print(&quot;----记录日记-args----&quot;) if arg == &quot;haha&quot;: functionName() # 此处相当于调用def test() functionName() else: print(&quot;---不记录---&quot;) return func_in return func@func_arg(&quot;haha&quot;)def test(): print(&quot;---test---&quot;)@func_arg(&quot;nihao&quot;)def test2(): print(&quot;---test2---&quot;)test()test2()#-----------结果-------------------记录日记-args-------test------test-------记录日记-args-------不记录--- 被装饰函数有参数传递 12345678910111213141516171819202122232425def func(functionName): print(&quot;---func---1---&quot;) # ② def func_in(a,b): # ③ print(&quot;---func_in---1---&quot;) # ⑧ functionName(a,b) # ⑨ ⑪ print(&quot;---func_in---2---&quot;) # ⑫ print(&quot;---func---2---&quot;) # ④ return func_in # ⑤@func # 裝飾器的效果 相当于第18行 test = func(test)def test(a,b): # ① ⑥ print(&quot;----test- a=%d,b=%d----&quot;%(a,b)) # ⑩# test = func(test)test(11,22) # ⑦ ⑬#-----------结果: 在第14、19行打斷點調試運行結果------------------func---1------func---2------func_in---1-------test- a=11,b=22-------func_in---2--- 被装饰函数有多个参数*args和**kwargs传递 1234567891011121314151617181920212223def func(functionName): print(&quot;---func---1---&quot;) def func_in(*args,**kwargs): print(&quot;---func_in---1---&quot;) functionName(*args,**kwargs) print(&quot;---func_in---2---&quot;) print(&quot;---func---2---&quot;) return func_in @func # 相当于 test_1 = func(test_1)def test_1(a,b,c,d): print(&quot;----test- a=%d,b=%d,c=%d,d=%d----&quot;%(a,b,c,d))#test_1 = func(test_1)test_1(11,22,33,44) # *args关键位置接受11，**kwargs关键字接受22,33,44#-----------结果------------------func---1------func---2------func_in---1-------test- a=11,b=22,c=33,d=44-------func_in---2--- 对带有返回值的函数装饰 123456789101112131415161718192021222324def func(functionName): print(&quot;----func----1----&quot;) def func_in(): print(&quot;----func_in----1---&quot;) xxxx = functionName() print(&quot;----func_in----2----&quot;) return xxxx print(&quot;----func----2----&quot;) return func_in @funcdef test(): print(&quot;----test----&quot;) return &quot;AAAA&quot;ret = test()print(&quot;test return value is %s&quot;%ret)#-----------结果-------------------func----1--------func----2--------func_in----1-------test--------func_in----2----test return value is AAAA 装饰的顺序 123456789101112131415161718192021222324252627def w1(func): print(&quot;----装饰1----&quot;) def inner(): print(&quot;-----验证通过1-----&quot;) func() return innerdef w2(func): print(&quot;----装饰2----&quot;) def inner(): print(&quot;-----验证通过2-----&quot;) func() return inner@w1@w2def f3(): print(&quot;----3----&quot;)f3()#-----------结果: 函数f3 对装饰内容就近原则，执行内部函数从上而下输出-------------------装饰2--------装饰1---------验证通过1----------验证通过2---------3---- 多个装饰器 1234567891011121314151617181920212223242526272829def makeBold(fn): def warpped(): print(&quot;-----1-----&quot;) return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot; return warpped# 定义函数: 完成数据包裹def makeItalic(fn): def warpped(): print(&quot;-----2-----&quot;) return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;/i&gt;&quot; return warpped@makeItalic # 先调用 -a- @makeBold # 然后 -b- def test3(): # 再执行 -c- print(&quot;-----3-----&quot;) return &quot;Hello,world-3&quot; ret = test3() print(ret) #-----------结果: 函数返回值多层装饰输出, 先函数f3的返回值，再遵循装饰就近原则--------------------2----------1----------3-----&lt;i&gt;&lt;b&gt;Hello,world-3&lt;/b&gt;&lt;/i&gt; 闭包闭包中外部函数返回的不是一个具体的值，而是一个函数。通常返回的函数会赋值给一个变量，后面会被继续执行调用。 计算移动平均值的类 1234567891011121314151617class Averager(): def __init__(self): self.series = [] def __call__(self, new_value): self.series.append(new_value) total = sum(self.series) return total/len(self.series)#--------------averager_oo.py-----------------&gt;&gt;&gt; from averager_oo import *&gt;&gt;&gt; avg = Averager()&gt;&gt;&gt; avg(10)10.0&gt;&gt;&gt; avg(11)10.5&gt;&gt;&gt; avg(12)11.0 计算移动平均值的高阶函数(闭包形式) 1234567891011121314151617181920212223242526def make_averager: series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averager # 返回值是 averager 函数#--------------averager.py-----------------&gt;&gt;&gt; from averager import *&gt;&gt;&gt; avg = make_averager()&gt;&gt;&gt; avg(10)10.0&gt;&gt;&gt; avg(11)10.5&gt;&gt;&gt; avg(12)11.0&gt;&gt;&gt; avg.__code__.co_varnames # __code__ 属性查看局部变量和自由变量('new_value', 'total')&gt;&gt;&gt; avg.__code__.co_freevars('series',)&gt;&gt;&gt; avg.__closure__(&lt;cell at 0x7f13cb64eee0: list object at 0x7f13ca9f9040&gt;,)&gt;&gt;&gt; avg.__closure__[0].cell_contents[10, 11, 12] 内置装饰器 @staticmethod和@classmethod ​ @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。 ​ @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。 12345678910111213141516171819202122class SayHi(): def __init__(self, name=None): self.name = name def func_1(self): print(&quot;say hello&quot;) @staticmethod def func_2(): # 无参数要求 print(&quot;say hi&quot;) @classmethod def func_3(cls): # 第一个参数必须cls print(&quot;say well&quot;)def main(): a = SayHi() a.func_1() SayHi.func_2() # 直接类名.方法名()来调用 SayHi.func_3() # 直接类名.方法名()来调用if __name__ == '__main__': main()#-----------结果---------------say hellosay hisay well @property @property 装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对“（）”小括号 1234567891011121314151617181920212223242526272829303132class C(object): def __init__(self): self._x = None @property def x(self): &quot;&quot;&quot;I'm the 'x' property.&quot;&quot;&quot; print(&quot;getx(): self._x=&quot;, self._x) return self._x @x.setter def x(self, value): self._x = value print(&quot;setx()&quot;) @x.deleter def x(self): print(&quot;del()&quot;) del self._xdef main(): a = C() a.x = 1 # 输出setx() a.x # 输出getx() del a.x # 输出del()if __name__ == &quot;__main__&quot;: main()#-----------结果-------------setx()getx(): self._x= 1del() 不使用装饰器形式的property函数 1234567891011121314151617181920212223242526272829class C(object): def __init__(self): self._x = None def getx(self): print(&quot;getx(): self._x=&quot;, self._x) return self._x def setx(self, value): self._x = value print(&quot;setx()&quot;) def delx(self): del self._x print(&quot;del()&quot;) y = property(getx, setx, delx)def main(): a = C() a.y = 1 a.y del a.yif __name__ == &quot;__main__&quot;: main()#-----------结果-------------setx()getx(): self._x= 1del()","link":"/posts/4059878826.html"},{"title":"redis非关系型数据库知识点","text":"REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库,Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。 redis安装 widows下安装 官网下载地址：根据系统选择相应的32位或64位安装包 12345678910111213# 在命令行cmd中启动redis服务redis-server.exe redis.windows.conf# 出现对应的redis运行界面，可以看到运行的端口6379# 切换到另一个cmd窗口，运行redisredis-cli.exe -h 127.0.0.1 -p 6379# 设置键值对set key1 abc# 读取键值对get key1 ubuntu中安装 1234567891011# 更新软件源sudo apt-get update# 下载redissudo apt-get install redis-server# 启动redis服务redis-server# 运行redisredis-cli 安装详情及Linux中编译安装教程 数据库特点 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启时再次加载 支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 支持数据的备份，即master-slave模式的数据备份 redis 总共有16个库，0-15select 15 选择15号库，默认0号库key-values key 同一个库不能重复 redis服务命令操作12345678# 卸载服务：redis-server --service-uninstall# 开启服务：redis-server --service-start# 停止服务：redis-server --service-stop redis中key的类型 type key：查看key的类型 none (key不存在) string (字符串) list (列表) set (集合) zset (有序集) hash (哈希表) 字符串string 1234set key valueget keymget key1 key2... 获取多个的key1 key2的值getrange key 0 -1 获取从头到尾的value字符串 hash 哈希 12345678hmset key file1 value1 file2 value2（多个字符串或值）hgetall key 获取哈希所有key-值hmget key file1 file2 获取key中某个file1 file2的值hdel key file1 删除key中file1的值hexists key file1 查询file1是否在key中hkeys key 获取哈希所有keyhvals key 获取哈希所有值hlen key 获取哈希表中字段的数量 list 列表 123456789101112lpush key value1 value2 value3 设置key的多个值lpush key value 在list前插入值lrange key 0 -1 查看key的所有值lindex key 1 索引key的第二个元素（0为第一个）llen key 获取key长度lpop key value 移除key中的元素lrem key -2 value 移除list中重复的元素（删除两个）lset key list集合移除重复的元素ltrim key 1 -1 修剪list的一个个元素rpop key 移除列表最后一个元素rpoplpush key1 key2 将key1最后一个元素移动到key2lrem key 0 'del' 删除列表中指定的值 set 集合 123456sadd key value1 value2smembers keysismember key value 查看value是否在key中scard key 查看集合key的元素个数srem key value 删除集合key中的valuemset key1 value1 key2 value2 设置一个或多个 key-value 对 zset 有序集合 12345678910zadd key value1 value2 设置有序集合zrange key 0 -1 查询有序集合zcard key 查询集合值的数量zrangebyscore key -inf +inf 查询key有序集合中所有成员（递增）zrangebyscore key -inf 5000 withscores 显示工资 &lt;=5000 的所有成员zrank key 成员 查询成员的排序zrem key1 key2 移除zrank salary 0 -1 withscores 递增排列 zrevrank salary 0 -1 withscores 递减排序zscore salary 成员 返回值 注意返回值是字符串","link":"/posts/1795835217.html"},{"title":"mysql关系数据库知识点精简版","text":"MySQL 是最流行的关系型数据库管理系统，web应用开发常用的数据库之一，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。 mysql数据库特点 是开源的，目前隶属于 Oracle 旗下产品。 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 使用标准的 SQL 数据语言形式。 可以运行于多个系统上，并且支持多种语言。 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。 创建数据库 创建并使用数据库 create datebase ‘mydatebase’; use ‘mydatebase’; 建表语句123456789101112131415161718192021222324create table `students`(`id` int not null auto_increment primary key, `name` varchar(200) not null);# 定义联合主键CREATE TABLE tb_enp4( name varchar(25), deptld int(11), salary float, PRIMARY KEY(name,deptld));# 较完整形式create table students(id int unsigned not null auto_increment primary key,name varchar(30),age tinyint unsigned default 0,high decimal(5,2),gender enum(&quot;男&quot;,&quot;女&quot;),cls_id int unsigned);sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVSION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 数据类型 数值类型 值数据类型(integer、smallint、decimal 和 numeric)，以及近似数值数据类型(float、real 和 double precision) 日期和时间类型 表示时间值的日期和时间类型为datetime(YYYY-MM-DD HH:MM:SS)、date(YYYY-MM-DD)、timestamp(YYYYMMDD HHMMSS)、time(HH:MM:SS)和year(YYYY)。 字符串类型 类型 大小 用途 char 0-255 bytes 定长字符串 varchar 0-65535 bytes 变长字符串 tinyblob 0-255 bytes 不超过 255 个字符的二进制字符串 tinytext 0-255 bytes 短文本字符串 blob 0-65 535 bytes 二进制形式的长文本数据 text 0-65 535 bytes 长文本数据 mediumblob 0-16 777 215 bytes 二进制形式的中等长度文本数据 mediumblob 0-16 777 215 bytes 中等长度文本数据 longblob 0-4 294 967 295 bytes 二进制形式的极大文本数据 longtext 0-4 294 967 295 bytes 极大文本数据 常见类型 int char varchar datetime 插入语句12345# 全部插入（先查看desc students, 表的数据结构）insert into students values (0,'小乔',18,160.00,02);# 部分插入或全部INSERT INTO `students` (`NAME`,`NICKNAME`,`SEX`) VALUES('小张','张哥','男'); 查询语句 普通查询 123456789101112131415161718192021222324# 字段查询SELECT name,nickname FROM students;# id 倒叙查询SELECT id,name,nickname FROM students WHERE sex='男' ORDER BY id DESC;# 按数据条数跳转查询: (0,2)表示从0开始2为步数跳转SELECT id,name,nickname FROM students WHERE sex='男' ORDER BY id DESC LIMIT 0,2;# 查看表的结构，名字，字段和字段属性desc students(表名);# 查看表内容select * from students;# 查看表的完整属性show create table studebts# 查询字段select * from students where id&gt;3; /* 满足条件的所有字段 */select name,gender from students; /* 指定的字段 */# 查看运行时间show profiles; 多条件+逻辑符号查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# and 同时满足条件select */字段名(表示所有字段) from 表名 where age&gt;18(条件)and age&lt;30; #or 满足一种条件select */字段名(表示所有字段) from 表名 where age&gt;18(条件)or gender=2; # not select */字段名(表示所有字段) from 表名 not(where age&gt;18(条件)or gender=2);同时否定两个条件select */字段名(表示所有字段) from 表名 notwhere age&gt;18(条件)or gender=2;否定not后面的条件。 # like 模糊查询select */name/字段名(表示所有字段) from 表名 where name like &quot;%小%&quot;；能查询名字中包含小的。select */name/字段名(表示所有字段) from 表名 where name like &quot;小%&quot; %代表字符或没有，能查询名字以小开头的。 # 查询名字是两个字select */name/字段名(表示所有字段) from 表名 where name like &quot;__&quot;(两个下划线);查询名字至少是两个字select */name/字段名(表示所有字段) from 表名 where name like &quot;__%&quot;; # rlike后面接正则表达式# 查询以周开始的姓名select */name/字段名(表示所有字段) from 表名 where name rlike &quot;^周.*&quot;;# 查询以周开始以伦结束的姓名select */name/字段名(表示所有字段) from 表名 where name rlike &quot;^周.*伦s&quot;; # in 查询年龄为12,18,30的select */字段名(表示所有字段) from 表名 not where age = 18 or age=22 or age=30;select */字段名(表示所有字段) from 表名 not where age in (18,22,30);# not in 查询年龄不是12,18,30的select */字段名(表示所有字段) from 表名 not where age not in (18,22,30);# 查询范围之内；# between...and..select */字段名(表示所有字段) from 表名 where age between 18 and 35;# 不在范围内select */字段名(表示所有字段) from 表名 where age not between 18 and 35;select */字段名(表示所有字段) from 表名 where not age not between 18 and 35; # 空值判断select */字段名(表示所有字段) from 表名 where 字段名 is null;# 不空select */字段名(表示所有字段) from 表名 where 字段名 is not null;# 排序# 按照年龄18到35的男性排序,默认从小到大select */字段名(表示所有字段) from 表名 where （age between 18 and 35）and gender=1 order by age;select */字段名(表示所有字段) from 表名 where （age between 18 and 35）and gender=1 order by age asc;# 从大到小,支持按照多字段排序。select */字段名(表示所有字段) from 表名 where （age between 18 and 35）and gender=1 order by age dasc，id dasc; /*先age后id*/ # 聚合函数# count总数select count(*) as 男性人数（显示注解）from students where gender=1(条件);# 最大值max,最小值min，求和sum，求平均值avgselect max/min/(age) from students;# 在students里女性的最大身高select max/sum(height) from students where gender=2;# 求平均值select sum(height)/count(*) from students where gender=2 # 保留几位小数round,还有四舍五入的作用select round(sum(height)/count(*),2(两位小数)) from students where gender=2; # 分组# group byselect gender(分组后的同一属性) from students group by gender;select gender，group_concat(name) from students group by gender; /* 可以显示分组后每一组里人的姓名 */# 分组后每一组的人数,count（*）是对分组后的数据进行聚合select gender，count(*) from students group by gender;select gender，max(age) from students group by gender;每组的最大年龄select gender，avg(age) from students group by gender;# 分组后男性的人数select gender，count(*) from students where gender=1 group by gender;# 分组后的跟多操作# 分组后查询男性的名字，id和年龄，中间添加空格。select gender，group_concat(name,' ',id,' ',gae) from students where gender=1 group by gender; # having对结果的判断，where对原始数据的判断所以写的位置不同。select gender，group_concat(name），avg(age) from students where gender=1 group by gender having avg(age)&gt;30;select gender，group_concat(name） from students where group by gender having avg(age)&gt;30 # 分页select * from students where 条件 limit 2;只显示两行；select * from students where 条件 limit 5（开始位置，根据列表，这是第六个），2（两行）;# 分页显示公式select * from students where 条件 limit （第m页-1）*n，n;不能直接输入. # 连接查询 # inner join ...on on取交集，两个表的匹配列的交集select *(表示显示所有字段) from students inner join calsses on students.cla_id=classes.id; /* 通过students表里的cla_id和classes表里的id字段匹配连接 */select s.name,c.name from students as s inner join calsses as c on s.cla_id=c.id; /* 只显示students表里的姓名和classes表里的班级。*/ # 例班级名字在前，学生所有信息在后，按班级排列后，按照id排列select c.name，s.* from students as s inner join calsses as c on s.cla_id=c.id order by c.name,s.id; # 左连接 left join on 两个表匹配以后把左边表的信息全部显示，右边表对不上的为空select c.name，s.* from students as s left join calsses as c on s.cla_id=c.id order by c.name,s.id; # 上边的语句可以当做新的表来查询select c.name，s.* from students as s left join calsses as c on s.cla_id=c.id order by c.name,s.id having c.id si null; /*查询两个表内无法匹配的内容。*/ # 自关联 同一个表里的不同列有关联，例如省市县select *(显示内容) from m（表1）as n inne join m（表1） as s（第二个名字，一个表就可以相当于两个表用。） on n.列=s.列 having（条件） n.列=??;# 把一个sql语句当做另一个sql语句的条件select * from students where height=(select max(height); 修改数据123456789101112# 按特定条件修改字段内容UPDATE students SET sex='女' WHERE id&lt;=2;# 添加字段alter table students(表名) add 字段名 数据类型;# 修改字段的数据类型alter table students modify 字段名 数据类型;# 修改字段的名称alter table students change 字段名 新名字 数据类型; 删除数据1234567891011121314151617# 按条件删除数据delete from students where name=**; # 删除字段alter table students dorp 字段名;# 删除表格dorp table students(表名)# 删除视图dorp view 视图名称# 逻辑删除# 逻辑删除增加新行进行删除标记alter table students add is_delete bit default 0;update students set is_delete = 1 where id=**; 其它123456789101112# 建立视图 用以方便查询create view 视图名称 as select 语句 # 查看视图show tables# 使用视图select * from 视图名称# 删除视图dorp view 视图名称 mysql详细使用参见该教程","link":"/posts/995647325.html"},{"title":"docker容器技术基础","text":"Docker简介Docker是一种基于go语言开发、开源的应用容器引擎。Docker公司原先是一家叫dotCloud平台的服务商，docker是dotCloud平台利用Linux容器技术开发形成一套内部工具。2103年dotCloud平台的业务开展艰难，新聘Ben Golub 作为CEO，将公司重命名为Docker，放弃原来的PaaS平台。向世界开放推广Docker和容器技术，当前docker版本分为社区版(CE：免费版)和企业版(EE：收费版)。 Docker三个基本概念： 镜像（Image）:Docker 镜像，就相当于是一个 root 文件系统 容器（Container）:容器可以被创建、启动、停止、删除、暂停等 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像 镜像和容器的关系: 镜像是静态的定义，容器是镜像运行时的实体 Docker特点： 借助Docker，你可以将容器当做重量轻、模块化的虚拟机来使用，同时，你还将获得高度的灵活性，从而实现对容器的高效创建、部署和复制，并能将其从一个环境顺利迁移至另外一个环境。 docker安装教程 官网教程 docker中文教程一 docker中文教程二 镜像操作 查看镜像 docker images 镜像存储在docker宿主机的/var/lib/docker的目录下 搜索镜像 docker search 镜像名 拉取镜像 docker pull 镜像名 删除镜像 docker rmi -f 镜像id # -f 表示强制删除 docker rmi ‘docker iamges -q’ #删除所有镜像 容器相关命令 查看容器 docker ps # 查看正在运行的容器 docker ps -a # 查看所容器 docker ps -l # 查看最后一次运行的容器 docker ps -f status=exited #停止所有容器 创建和启动容器 1234567docker run -it --name=容器名称 镜像名称：标签/bin/bash-i # 表示运行容器-t # 表示容器启动后并进入其命令行模式--name # 为创建的容器命名-v # 表示目录映射关系（目录挂载）-p # 表示端口映射 -d # 创建一个守护式容器在后台运行，但不登录 1234567# 案例：# 直接进入容器的命令模式docker run -it --name=mycentos centos:7 /bin/bash# 进入容器后台守护模式 退出容器不影响其运行docker run -di --name=mycentos2 centos:7docker exec -it mycentos2 /bin/bash #进入到命令模式 exce表示执行 退出 exit docker stop 容器name或者id # 停止后台运行的容器，相当杀死后台 docker start 容器name或者id # 启动容器 宿主机和容器之间文件传输 docker cp 文件名 mycentos2:/usr/local # 从宿主机到容器 docker cp mycentos2:/usr/local/文件名 宿主机路径 # 不加路径和名字默认为根目录 文件共享目录 docker run -di -v /usr/local/mydata:/usr/local/mydata –name=mycentos3 centos:7 #共享文件夹路径/usr/local/mydata（在创建容器的时候挂载） 查看容器内部运行的数据 123docker inspect mycentos3docker inspect --format={{.NetworkSettings.IPAddress}} mycentos3 # 查看容器的ip 删除容器 docker rm 容器名称或id # 前提先停止容器运行: docker stop mycentos3 常用容器部署mysql部署 拉取mysql镜像 docker pull mysql:5.7 部署镜像 docker run -di –name=mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.7 ​ -e MYSQL_ROOT_PASSWORD=root # 初始化mysql登录配置 ​ 3306:3306 # 宿主机与容器端口映射 启动mysql docker exec -it mysql /bin/bash 进入mysql mysql -uroot -proot –default-character-set=utf8 ​ -proot #设置初始密码为root ​ –default-character-set=utf8 # 初始编码格式为utf8 mysql常用查询命令 show databases; # 查数据库 use mysql（数据库名） # 选择数据库 show tables; # 查表格 desc 表名; # 显示表结构 Nginx部署 拉取nginx镜像 docker pull nginx # 拉取最新版的nginx 部署到后台运行 docker run -di –name=nginx -p 80:80 nginx ​ 80:80 # 宿主机和容器端口映射 ​ 宿主机ip:80 # 浏览器访问nginx 配置nginx一般过程 1234567891011121314# 将容器nginx配置文件拷贝到宿主机上修改docker cp nginx:/etc/nginx /usr/local/mydata/nginx # 将文件重命名，修改nginx相关配置mv ngnix conf # 停止nginx运行docker stop nginx# 删除nginx镜像docker rm nginx# 重新部署并配置挂载目录docker run -di --name=nginx -p 80:80 -v /usr/local/mydata/conf:/etc/nginx nginx redis部署 拉取redis镜像 docker pull redis 部署到后台运行 docker run -di –name=redis -p 6379:6379 redis 可视化工具访问 宿主机ip：6379 rabbitmq部署 实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件） 拉取镜像 docker pull rabbitmq:3.7.12 # 常用版本 部署后台运行 docker run -di –name=rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:3.7.12 进入rabbitmq docker exec -it rabbitmq /bin/bash 激活rabbitmq的ui界面插件，并通过网页访问 rabbitmq-plugins enable rabbitmq_management # 激活插件 宿主机ip + 端口: 15672 # 访问网页端rabbitmq 初始账号密码：guest Elasticsearch部署 Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。 拉取镜像 docker pull elasticsearch 修改虚拟内存区域大小，否者会因为过小而无法启动 sysctl -w vm.max_map_count=262144 # 此步骤关键，宿主机内存过小是个问题 启动，环境配置，目录挂载 docker run -di –name=elasticsearch -p 9300:9300 -e “discovery.type=single-node” -e “cluster.name=elasticsearch” -v /usr/local/mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins elasticsearch:7.5.0 在elasticsearch容器中安装插件 elasticsearch-plugins install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.5.0/elasticsearch-analysis-ik-7.5.0.zip # ik中文分词器 安装完成后在容器外部重启elasticsearch docker restart elasticsearch 在网页上访问 宿主机ip + 端口（9300） Zookeeper部署 分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 拉取镜像 docker pull zookeeper:3.4.13 部署后台运行 docker run -di –name=zookeeper -p 2181:2181 zookeeper 迁移和备份 容器保存为镜像 docker commit redis myredis # 将redis 打包成myredis镜像文件 镜像备份 docker save -o myredis.tar myredis # 备份镜像 恢复备份 docker load -i myredis.tar Dockerfile 由一系列的命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量（可以多写） RUN command Dockerfile的核心（可以多写） ADD sourece_dir/filedest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/filedest_dir/file 和ADD 相似，但是如果有压缩文件并不会解压 WORKDIR path_dir 设置工作目录 使用脚本创建镜像（示例：基于centos7 构建jdk8） 12345678910# DockerfileFROM centos:7MAINTAINER xxxxWORKDIR /usrRUN mkdir /usr/local/javaADD jdk-8u211-linux-x64.tar.gz /usr/local/javaENV JAVA_HOME /usr/local/java/jdk1.8.0_211ENV PATH $JAVA_HOME/bin/:$PATH 构建镜像 docker build -t=“jdk1.8” . # 点前面有空格，点指定为当前目录的Dockerfile Docker私有仓库私有仓库的搭建和配置 拉取私有仓库镜像 docker pull registry 启动私有仓库容器 docker run -di –name=registry -p 5000:5000 registry 仓库地址 https://宿主机ip:5000/v2/_catalog 修改daemon.json vim /etc/docker/daemon.json 1234# daemon.json{&quot;insecure-registries&quot;:[“宿主机ip”:5000]} 重启docker服务 systemctl restart docker 仓库镜像上传 镜像打标签 docker tag jdk1.8 宿主机ip:5000/jdk1.8 # 前面为镜像名称，后面为镜像的标签名 上传 docker push 宿主机ip:5000/jdk1.8 # 标签格式固定 拉取镜像 安装docker，配置vim /etc/docker/daemon.json内容，然后重启systemctl restart docker {“insecure-registries”:[“宿主机ip”:5000]} DockerMaven插件Maven插件部署步骤 修改宿主机的docker配置，使其允许远程访问 vim /lib/systemd/system/docker.service 修改ExecStart开头行 1234ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock# 修改为ExecStart=ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 刷新配置 systemctl daemon-reload # 刷新配置daemon.json systemctl restart docker # 重启docker 启动registry systemctl start registry # 重启registry容器 将java项目打包成镜像 此处略过视频内容，详情查看maven插件教程 启动镜像后台运行 docker run -di –name=test -p 7070:7070 镜像名称 网页访问 宿主机ip:7070 其它常用命令 启动 开机启动： sudo systemctl enable docker.service 禁止开机启动：sudo systemctl disable docker.service 非root用户操作docker更改权限 sudo groupadd docker # 创建docker用户组 sudo usermod -aG docker $USER # 添加docker到用户组中 newgrp docker # 激活用户组 重新加载和重启docker sudo systemctl daemon-reload # 重新加载配置 sudo systemctl restart docker # 重启 查看建立的链接 sudo netstat -tanlp","link":"/posts/3708940461.html"},{"title":"python虚拟环境的搭建方式","text":"在Python搭建项目常常会在一个封闭而独立的虚拟环境中操作，以便于后续项目的打包迁移到服务器等其它设备中加载运行。当前Python虚拟环境搭建常用工具有virtualenv/ venv/pipenv。 virtualenv和venv使用方式相似，依赖模块环境在requirements.txt，需要手动更新内容 pipenv搭建环境会生成Pipfile和Pipfile.lock 两个特殊文件，项目所有模块环境包信息都会自动实时更新，项目迁移只需要将项目源码和这两个文件，在新的环境中（pipenv install –dev）一键安装其中的依赖包 virtualenv或venv 演示在Linux（ubuntu 20.04)环境下virtualenv和venv安装 安装virtualenv或venv模块 1234567# virtualenvpip3 install virtualenv # 可以使用对python版本的pip进行安装 如# venv [linux(Ubuntu)]sudo apt install python3.9-venv # 此处python最好指定搭建项目使用python的版本来安装# windows#在python3.3版本以后，venv作为标准模块配套在python环境中，无需单独安装 创建项目文件夹,并进入 12mkdir my_projectcd my_project 创建python虚拟环境文件夹为：my_env 1234567# virtualenvvirtualenv --no-site-packages my_env# venvpython3 -m venv my_env# windowspy -3 -m venv my_env –no-site-packages参数说明：忽略配置系统中python环境所有第三方包，创建初始化pyhton环境 文件my_env：包含独立于系统外的pyhton文件 激活虚拟环境 123456# virtualenv# venvsource my_env/bin/activate # 两者命令相同#windowsmy_env\\Scripts\\activate.bat # windows 命令使用反斜杠\\ 激活后，命令行前缀会加上“(my_env)”虚拟环境文件夹名，与pipenv有点不同，后者添加当前文件夹名 安装第三方包及运行文件方式 1234# 安装模块环境pip install requests # 跟正常系统中安装方式一样，只不过安装包配置在当前虚拟环境中# 运行文件python demo_01.py pip常用命令： (前面加上 python -m 指定特定python版本) python -m pip install 包名 -i 代理url python -m pip uninstall 包名 pip show 包名 将显示有关特定包的信息 pip list 将显示虚拟环境中安装的所有软件包 pip freeze &gt; requirements.txt 将生成一个类似的已安装包列表，txt格式文件 python -m pip install -r requirements.txt 安装所有必需的包 退出虚拟环境 123exit# 或者deactivate 详细教程参考官网 pipenv 将 pip 和 virtualenv 功能结合，更加符合项目迁移快速部署的pipenv，是当下主流推荐使用搭建pyhton虚拟环境的不二选择。 安装pipenv（前提安装pip ） sudo apt install python3-pip 安装pip，若安装忽略 12345sudo pip install pipenv # 正常安装sudo pip install --user pipenv # --user可以单独给当前用户安装，但需要额外配置环境sudo -H pip install -U pipenv # 全局安装 pipenv 查看安装环境配置是否成功 12~$ pipenv --version # 显示版本号成功配置pipenv, version 2021.5.29 若安装配置环境失败，可以参考此博文详细说明 创建项目文件，并进入 12mkdir my_projectcd my_project 创建虚拟环境 1pipenv install # 会生成Pipfile 和 Pipfile.lock 两个项目依赖环境包 下载第三方包 1pipenv install pillow # 模块pillow 生成Pipfile 和 Pipfile.lock项目文件 Pipfile: 列出了 pillow包的信息和 Python 版本信息 Pipfile.lock ： 保存了pillow包的哈希值 注：迁移项目时，在这两个文件所在文件中，执行pipenv install，即可安装开发所需的第三包 123456789101112131415# Pipfile文件[[source]]# pipenv 下载第三方包地址，可以更换成国内pip镜像源，如阿里等url = &quot;https://mirrors.aliyun.com/pypi/simple/&quot; verify_ssl = truename = &quot;pypi&quot;[packages] # 第三方包信息pillow = &quot;*&quot; # 表示最新版本[dev-packages] # pipenv install pillow --dev 这种方式安装包会在此处显示[requires]python_version = &quot;3.9&quot; 12345678910111213141516171819202122232425262728# Pipfile.lock文件{ &quot;_meta&quot;: { &quot;hash&quot;: { &quot;sha256&quot;: &quot;50541ebd1e358e19fd1abf7ff833c7dbd5e3484685f8b85c606d51ffe7892041&quot; }, &quot;pipfile-spec&quot;: 6, &quot;requires&quot;: { &quot;python_version&quot;: &quot;3.9&quot; }, &quot;sources&quot;: [ { &quot;name&quot;: &quot;pypi&quot;, &quot;url&quot;: &quot;https://mirrors.aliyun.com/pypi/simple/&quot;, &quot;verify_ssl&quot;: true } ] }, &quot;default&quot;: { &quot;pillow&quot;: { &quot;hashes&quot;: [ &quot;sha256:0412516dcc9de9b0a1e0ae25a280015809de8270f134cc2c1e32c4eeb397cf30&quot;, ], &quot;index&quot;: &quot;pypi&quot;, &quot;version&quot;: &quot;==8.3.2&quot; } }, &quot;develop&quot;: {}} pipenv常用命令 直接在命令行中输入 pipenv 可查看它的子命令 1234567891011121314151617181920212223242526272829303132333435# 创建指定python版本的虚拟环境pipenv --python 3.9# 激活项目虚拟环境pipenv shell# 退出虚拟环境exit 或 deactivate# 安装第三方包pipenv install xxxx# 升级包pipenv update# 删除包pipenv uninstall xxxx# 删除所有包pipenv uninstall --all# 删除项目配置的虚拟环境pipenv --rm# 检查项目依赖库信息pipenv graph# 获取虚拟环境的配置路径pipenv --venv# 获取当前项目路径pipenv --where# 运行py文件(未激活虚拟环境)pipenv run python xxx.py pipenv使用详解参见 pipenv官网 Pipenv详解","link":"/posts/519438566.html"},{"title":"Ubuntu20.04下mysql数据库相关操作","text":"安装mysql、重置密码 更新下载源：sudo apt-get update 安装：sudo apt install mysql-server 安装mysql客户端：sudo apt install mysql-client 重启mysql服务：sudo service mysql restart 配置mysql：sudo mysql_secure_installation 接上述内容 接上述内容 用最大权限直接登陆mysql select user,authentication_string,plugin,host from mysql.user; 直接输入重置密码：ALTER USER ‘root‘@’localhost’ IDENTIFIED BY “123456”; 结果大概率报错（ERROR 1819），显示密码过于简单不满足要求 查看密码要求： show variables like ‘validate_password%’; 密码重置配置 mysql&gt; set global validate_password.policy=0; Query OK, 0 rows affected (0.00 sec) mysql&gt; set global validate_password.length=1; Query OK, 0 rows affected (0.01 sec) mysql&gt; alter user ‘root’@‘localhost’ identified by ‘123456’; Query OK, 0 rows affected (0.04 sec) mysql&gt; flush privileges; Query OK, 0 rows affected (0.04 sec) mysql&gt; ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH caching_sha2_password by ‘123456’; Query OK, 0 rows affected (0.04 sec) 详情参考该博文 Ubuntu下彻底卸载mysql数据库1234567891011121、查看相关文件dpkg --list|grep mysql2、卸载sudo apt-get remove mysql-common3、卸载sudo apt-get autoremove --purge mysql-server-5.74、清除残留数据dpkg -l|grep ^rc|awk '{print$2}'|sudo xargs dpkg -P5、查看MySQL的剩余依赖项dpkg --list|grep mysql6、继续删除剩余依赖项sudo apt-get autoremove --purge mysql-apt-config","link":"/posts/1178053341.html"},{"title":"python学习笔记","text":"python内置函数(一) abs() #取绝对值 1234567#abs()是python内置函数,而fabs()是math中的一个模块#fabs() 函数只适用于 float 和 integer 类型，而 abs() 也适用于复数。import mathd = 1+1.0je = 3+4.0jprint(f&quot;d的绝对值:&quot;,abs(d)) #结果为1.4142135623730951print(f&quot;e的绝对值:&quot;,math.fabs(e)) #结果会报错TypeError: can't convert complex to float dict() #创建一个字典 123456789&gt;&gt;&gt; dict() #创建字典{}&gt;&gt;&gt; dict(a=&quot;a&quot;,b=&quot;b&quot;,c=&quot;c&quot;) #key-alue 传入参数{'a': 'a', 'b': 'b', 'c': 'c'}&gt;&gt;&gt; dict(zip([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])) #映射函数方式创建字典{'a': 'A', 'b': 'B', 'c': 'C'}&gt;&gt;&gt; dict([(&quot;one&quot;,1),(&quot;two&quot;,2),(&quot;three&quot;,3)]) #可迭代对象来构造字典，列表为iterable{'one': 1, 'two': 2, 'three': 3} help () #参看对象的帮助信息 1234567891011&gt;&gt;&gt;help('sys') # 查看 sys 模块的帮助……显示帮助信息…… &gt;&gt;&gt;help('str') # 查看 str 数据类型的帮助……显示帮助信息…… &gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt;help(a) # 查看列表 list 帮助信息……显示帮助信息…… &gt;&gt;&gt;help(a.append) # 显示list的append方法的帮助 min () #返回给定参数的最小值 12&gt;&gt;&gt; print (&quot;min(80, 103, 1440) : &quot;, min(80, 103, 1440))min(80, 103, 1440) : 80 setattr() #设置属性值，属性不一定存在 123456789&gt;&gt;&gt; class A():... bar = 1... &gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a,&quot;bar&quot;) #获取属性bar值1&gt;&gt;&gt; setattr(a,&quot;b&quot;,2) #设置属性b值&gt;&gt;&gt; a.b2 all() #用于判断给定的可迭代对象iterable中所有元素是否都为True，元素除了是 0、空、None、False 外都算 True。 1234567891011121314151617#iterable 是元组或列表 空元组、空列表返回值为True，这里要特别注意。&gt;&gt;&gt; all(['a','b','c','d']) # 列表list，元素都不为空或0True&gt;&gt;&gt; all(['a','b','','d']) # 列表list，存在一个空的元素False&gt;&gt;&gt; all([0,2,3,4]) # 列表list，存在一个为0的元素False&gt;&gt;&gt; all(('a','b','c','d')) # 元组tuple，元素都不为空或0True&gt;&gt;&gt; all(('a','b','','d')) # 元组tuple，存在一个空的元素False&gt;&gt;&gt; all((0,1,2,3)) # 列表list，存在一个为0的元素False&gt;&gt;&gt; all([]) # 空列表True&gt;&gt;&gt; all(()) # 空元组True dir() #函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。 12&gt;&gt;&gt;dir() # 获取当前模块的属性列表&gt;&gt;&gt;dir([]) # 参看列表的方法 hex() #函数用于将一个指定数字转换为 16 进制数,返回的是一个字符串，以0x开头 12345678&gt;&gt;&gt; hex(255)'0xff'&gt;&gt;&gt; hex(-42)'-0x2a'&gt;&gt;&gt; hex(12)'0xc'&gt;&gt;&gt; type(hex(12)) #查看类型&lt;class 'str'&gt; next() #返回迭代器的下一个项目，和生成迭代器的 iter() 函数一起使用 1234567891011121314&gt;&gt;&gt; li=[3,6,4,63,5]&gt;&gt;&gt; it = iter(li) #首先获得Iterator对象&gt;&gt;&gt; while True:... y =next(it,&quot;aa&quot;)... print(y)... if y == &quot;aa&quot;:... break...364635aa slice() #函数实现切片对象，主要用在切片操作函数里的参数传递 slice(start, stop[, step])—step间距 123456789101112&gt;&gt;&gt; myslice = slice(3) # 设置截取3个元素的切片&gt;&gt;&gt; mysliceslice(None, 3, None)&gt;&gt;&gt; arr = list(range(6))&gt;&gt;&gt; arr[0,1,2,3,4,5] &gt;&gt;&gt; arr[myslice] # 截取 3 个元素[0,1,2]&gt;&gt;&gt;myslice1 = slice(0,7,2)&gt;&gt;&gt;arr1 = list(range(10))&gt;&gt;&gt;arr1[myslice1][0, 2, 4, 6] any() #函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True 1234567891011121314151617#如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。&gt;&gt;&gt;any(['a', 'b', 'c', 'd']) # 列表list，元素都不为空或0True&gt;&gt;&gt; any(['a', 'b', '', 'd']) # 列表list，存在一个为空的元素True&gt;&gt;&gt; any([0, '', False]) # 列表list,元素全为0,'',falseFalse&gt;&gt;&gt; any(('a', 'b', 'c', 'd')) # 元组tuple，元素都不为空或0True&gt;&gt;&gt; any(('a', 'b', '', 'd')) # 元组tuple，存在一个为空的元素True&gt;&gt;&gt; any((0, '', False)) # 元组tuple，元素全为0,'',falseFalse&gt;&gt;&gt; any([]) # 空列表False&gt;&gt;&gt; any(()) # 空元组False divmod() #接受两个非复数类型的数字，返回商和余数的元组 123456&gt;&gt;&gt; divmod(7,2) //相当于（a//b,a%b）(3, 1)&gt;&gt;&gt; divmod(3,-1.3)(-3.0, -0.9000000000000001)&gt;&gt;&gt; divmod(6,-2)(-3, 0) id() #获取对象的内存地址 1234567891011121314151617181920&gt;&gt;&gt; aa=1&gt;&gt;&gt; id(aa)9788608&gt;&gt;&gt; bb=1 &gt;&gt;&gt; id(bb)9788608&gt;&gt;&gt; a=&quot;whoami&quot;&gt;&gt;&gt; id(a)140185507204528#-------注意--------#在对象内存数字类型较小时，对象的内存地址是一样的，一般情况不一样&gt;&gt;&gt; a = 1234&gt;&gt;&gt; id(a)140185507593328&gt;&gt;&gt; b = 1234&gt;&gt;&gt; id(b)140185507593424&gt;&gt;&gt; b = a&gt;&gt;&gt; id(b)140185507593328 object() #对象，类默认的对象 sorted() #对可迭代的对象(列表，元组)进行排列 12345678910111213141516171819202122232425# sort 和 sorted区别：# sort 对原来的列表排序操作，sorted 对可迭代对象操作并生成新的列表&gt;&gt;&gt; sorted([4,7,2,8])[2, 4, 7, 8]&gt;&gt;&gt; a = [4,7,2,8]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[2, 4, 7, 8]#----------sorted常用-------------&gt;&gt;&gt; sorted({1:&quot;d&quot;,2:&quot;b&quot;,3:&quot;c&quot;,4:&quot;a&quot;}) //接受任何的iterable[1, 2, 3, 4]&gt;&gt;&gt; li = [5,9,3,2,6,8]&gt;&gt;&gt; result_li=sorted(li, key = lambda y:y*-1) //将序&gt;&gt;&gt; result_li[9, 8, 6, 5, 3, 2]&gt;&gt;&gt; sorted(li, reverse = True)[9, 8, 6, 5, 3, 2]&gt;&gt;&gt; sorted(li, reverse = False)[2, 3, 5, 6, 8, 9]#------------实例应用------------# score降序排列，同条件下对name升序&gt;&gt;&gt; d1 = [{'name':'alice', 'score':38}, {'name':'bob', 'score':18}, {'name':'darl', 'score':28}, {'name':'christ', 'score':28}]&gt;&gt;&gt; ll = sorted(d1, key = lambda x:(-x[&quot;score&quot;],x[&quot;name&quot;]))&gt;&gt;&gt; ll[{'name': 'alice', 'score': 38}, {'name': 'christ', 'score': 28}, {'name': 'darl', 'score': 28}, {'name': 'bob', 'score': 18}] ascii() #返回表示对象的字符串，对于字符串中的非 ASCII 字符则返回通过 repr() 函数使用 \\x, \\u 或 \\U 编码的字符 1234&gt;&gt;&gt; ascii('whoami') //与repr()用法相似&quot;'whoami'&quot;&gt;&gt;&gt; print(repr('#'))'#' enumerate() #用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 1234567891011121314151617181920212223#--------列出数据的下标和它本身--------&gt;&gt;&gt; li = ['Spring','Summer','Fall','Winter']&gt;&gt;&gt; list(enumerate(li))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]&gt;&gt;&gt; list(enumerate(li,start=2))[(2, 'Spring'), (3, 'Summer'), (4, 'Fall'), (5, 'Winter')]#---------在for中的应用---------&gt;&gt;&gt; i = 1&gt;&gt;&gt; li = ['one','two','three','four']&gt;&gt;&gt; for element in li:... print(i, li[i])... i +=1... 1 two2 three3 four#或者for i, element in enumerate(li): print(i, element)0 one1 two2 three3 four input() #接受一个标准输入数据，返回string数据类型 1234567891011121314151617181920&gt;&gt;&gt; aa = input(&quot;&gt;&gt;&gt;:&quot;)&gt;&gt;&gt;:123&gt;&gt;&gt; type(aa) //查看aa对象的类型&lt;class 'str'&gt;&gt;&gt;&gt; bb = input(&quot;&gt;&gt;&gt;:&quot;)&gt;&gt;&gt;:string&gt;&gt;&gt; type(bb)&lt;class 'str'&gt;#-------接受多个值-------&gt;&gt;&gt; a,b,c = (input(&quot;请输入三角形三边的长：&quot;).split())请输入三角形三边的长：3 4 5&gt;&gt;&gt; a = int(a)&gt;&gt;&gt; b = int(b)&gt;&gt;&gt; c = int(c)&gt;&gt;&gt; p = (a+b+c)/2&gt;&gt;&gt; p6.0&gt;&gt;&gt; s = (p*(p-a)*(p-b)*(p-c))**0.5&gt;&gt;&gt; print(f&quot;三角形的面积为:{s}&quot;)三角形的面积为:6.0 oct() #将整数转化成8进制字符串，以0o作为前缀 1234&gt;&gt;&gt; oct(12)'0o14'&gt;&gt;&gt; oct(1)'0o1' staticmethod #返回函数的静态方法 12345678910&gt;&gt;&gt; class A(object):... @staticmethod... def f():... print(&quot;hello&quot;)... &gt;&gt;&gt; A.f() // 无实例调用函数hello&gt;&gt;&gt; cobj = A() // 实例化后调用&gt;&gt;&gt; cobj.f()hello bin() #返回一个整数int或者长整数long int的二进制 1234&gt;&gt;&gt; bin(100)'0b1100100'&gt;&gt;&gt; bin(11)'0b1011' eval() #执行一个字符串表达式，并返回表达式的值 1234567&gt;&gt;&gt; a = 3&gt;&gt;&gt; eval(&quot;a+1&quot;) //计算字符串里的内容4&gt;&gt;&gt; eval(&quot;pow(2,3)&quot;)8&gt;&gt;&gt; eval(&quot;3*4&quot;)12 int() # 将一个字符串或数字转换为整型 123456789101112&gt;&gt;&gt; int() //没有参数为00&gt;&gt;&gt; int(3) //3&gt;&gt;&gt; int(4.6) //取整数部分4&gt;&gt;&gt; int(&quot;12&quot;,16) //将十六进制12，转化成十进制18&gt;&gt;&gt; int(&quot;0xa&quot;,16) 10&gt;&gt;&gt; int(&quot;10&quot;,8) //将八进制转化成十进制8 open() #用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError 语法格式： open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 123456789101112file: 必需，文件路径（相对或者绝对路径）。mode: 可选，文件打开模式buffering: 设置缓冲encoding: 一般使用utf8errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型opener:#---------------------------------&gt;&gt;&gt;f = open('test.txt')&gt;&gt;&gt;f.read()&gt;&gt;&gt;f.close() mode 的参数详述：(默认为文本模式，加b就可以用二进，针对图形影视文件) 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 str() #将对象格式化成string 123456&gt;&gt;&gt; dict = {'baidu': 'baidu.com', 'google': 'google.com'} //格式化成字符串&gt;&gt;&gt; str(dict)&quot;{'baidu': 'baidu.com', 'google': 'google.com'}&quot;&gt;&gt;&gt; a = 'bingeone'&gt;&gt;&gt; str(a)'bingeone' bool() #将给定的对象转换成布尔类型，True 或者 False 12345678910&gt;&gt;&gt; bool()False&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(10)True&gt;&gt;&gt; issubclass(bool,int) //bool 是 int的子类True exec() #执行存储在字符串或文件中的python语句 123456789101112131415161718192021222324252627&gt;&gt;&gt; exec(&quot;print('hello,world')&quot;)hello,world&gt;&gt;&gt; exec(&quot;&quot;&quot;for i in range(3):... print(&quot; iter time: %d&quot; %i)... &quot;&quot;&quot;) iter time: 0 iter time: 1 iter time: 2#---------------------------------x = 10expr = &quot;&quot;&quot;z = 30sum = x + y + zprint(sum)&quot;&quot;&quot;def func(): y = 20 exec(expr) // 10+20+30 exec(expr, {'x': 1, 'y': 2}) // 1+2+30 exec(expr, {'x': 1, 'y': 2}, {'y': 3, 'z': 4}) // 1+3+30，两个y取后者，z取定义的，不用传递的4 func()结果：603334 isinstance() #判断一个对象是否是一个已知的类型 与type() 的区别 type() 不会认为子类是父类类型，不考虑继承关系 isinstance() 会认为子类是父类类型，考虑继承关系 可以使用isinstance() 来判断两个类型是否相同 isinstance(object, classinfo) 123456789101112131415161718192021222324&gt;&gt;&gt; a = 2&gt;&gt;&gt; isinstance(a,int)True&gt;&gt;&gt; isinstance(a,str)False&gt;&gt;&gt; isinstance(a,(str,int,list)) // 在元组中满足一个，就返回TrueTrue#基本类型 classinfo：# int，float，bool，complex，str(字符串)，list，dict(字典)，set，tuple#-------------------------------&gt;&gt;&gt; class A:... pass... &gt;&gt;&gt; class B(A): // B类继承A类... pass... &gt;&gt;&gt; isinstance(A(),A) //实例A 和类A 一个类型True&gt;&gt;&gt; type(A()) == ATrue&gt;&gt;&gt; isinstance(B(),A) True&gt;&gt;&gt; type(B()) == AFalse ord() # 返回对应的 ASCII 数值，或者 Unicode 数值，对应的十进制整数。 1234&gt;&gt;&gt; ord('a')97&gt;&gt;&gt; ord('$')36 sum() #对序列进行求和计算 123456&gt;&gt;&gt; sum([1,2,3])6&gt;&gt;&gt; sum((2,3,4),1) //对元组求和后，再加110&gt;&gt;&gt; sum([0,1,2,3,4],2)12 batearray() #返回一个新字节数组 bytearray([source[, encoding[, errors]]]) 1234567891011121314'''如果 source 为整数，则返回一个长度为 source 的初始化数组；如果 source 为字符串，则按照指定的 encoding 将字符串转换为字节序列；如果 source 为可迭代类型，则元素必须为[0 ,255] 中的整数；如果 source 为与 buffer 接口一致的对象，则此对象也可以被用于初始化 bytearray。如果没有输入任何参数，默认就是初始化数组为0个元素。'''#----------------------------------------------------------&gt;&gt;&gt; bytearray()bytearray(b'')&gt;&gt;&gt; bytearray([1,2,3])bytearray(b'\\x01\\x02\\x03')&gt;&gt;&gt; bytearray('hello','utf-8')bytearray(b'hello') filter() #用于过滤序列，过滤不符合条件的元素，返回一个迭代器对象，可以用list将其转化成列表 filter(function, iterrable) 123456789101112131415&gt;&gt;&gt; def is_sqr(n):... return n %2 == 1 //对2取余，求n为奇数... &gt;&gt;&gt; tmp = filter(is_sqr, [1,2,3,4,5,6,7,8])&gt;&gt;&gt; list(tmp)[1, 3, 5, 7]#-------------------------------------------&gt;&gt;&gt; import math //引入math模块&gt;&gt;&gt; def is_sqr(x):... return math.sqrt(x) % 1== 0 //求开平方根得到整数的对象... &gt;&gt;&gt; tmplist = filter(is_sqr, range(1,101))&gt;&gt;&gt; newlist = list(tmplist)&gt;&gt;&gt; newlist[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] issubclass() #用于判断参数class是否是类型参数classinfo的子类 issubclass(class, classinfo) 12345678&gt;&gt;&gt; class A(object):... pass... &gt;&gt;&gt; class B(A):... pass... &gt;&gt;&gt; print(issubclass(B,A))True pow() #返回x^y^ 的值 1234567891011&gt;&gt;&gt; import math&gt;&gt;&gt; math.pow(100,2) //保留一位小数10000.0&gt;&gt;&gt; pow(100,2)10000&gt;&gt;&gt; math.pow(100,-2)0.0001&gt;&gt;&gt; math.pow(2,3)8.0&gt;&gt;&gt; math.pow(100,0)1.0 super() #用于调用父类(超类)的一个方法 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; class A:... def add(self,x):... y = x+1... print(y)... &gt;&gt;&gt; class B(A):... def add(self,x):... super().add(x) //调用父类中的add函数... &gt;&gt;&gt; b = B()&gt;&gt;&gt; b.add(2)3#--------------------------------class FooParent(object): def __init__(self): self.parent = 'I\\'m the parent.' print(&quot;Parent&quot;) def bar(self,message): print(&quot;%s from Parent&quot; % message)class FooChild(FooParent): def __init__(self): super(FooChild,self).__init__() //步骤① print(&quot;Child&quot;) //步骤② def bar(self,message): super(FooChild,self).bar(message) //步骤③ print('Child bar function') //步骤④ print(self.parent) //步骤⑤if __name__ == &quot;__main__&quot;: fooChild = FooChild() //执行结果打印前两个结果 fooChild.bar(&quot;Helloworld&quot;) //打印后三个结果：ParentChildHelloworld from ParentChild bar functionI'm the parent. ​ ​ 内置函数第二部分详见下文。。。内置函数(二) ​","link":"/posts/1847936831.html"},{"title":"Python学习&lt;第一部分&gt;","text":"定义有序的纸牌类 rank: 2345…910JQKA // 牌等级 suit: spades,hearts,clubs,diamonds //花色 除去大小王，实现一幅数字与花色匹配、有序的52组元组的牌类 frenchDeck.py >folded12345678910111213141516import collectionsCard = collections.namedtuple('Card',['rank','suit'])class FrenchDeck: ranks = [str(n) for n in range(2,11)] + list('JQKA') suits = 'spades hearts clubs diamonds'.split() def __init__(self): # 生成一个按花色分组的 52 张牌的列表，其中每个花色各有 13 张不同点数的牌。 self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&gt;&gt;&gt; from frenchDeck import *&gt;&gt;&gt; deck = FrenchDeck()&gt;&gt;&gt; suit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0) //定义黑桃最大、红桃次之、方块再次、梅花最小&gt;&gt;&gt; def spades_high(card):... rank_value = FrenchDeck.ranks.index(card.rank)... return rank_value * len(suit_values) + suit_values[card.suit]... &gt;&gt;&gt; for card in sorted(deck, key=spades_high):... print(card)... Card(rank='2', suit='clubs')Card(rank='2', suit='diamonds')Card(rank='2', suit='hearts')Card(rank='2', suit='spades')Card(rank='3', suit='clubs')Card(rank='3', suit='diamonds')Card(rank='3', suit='hearts')Card(rank='3', suit='spades')...Card(rank='A', suit='clubs')Card(rank='A', suit='diamonds')Card(rank='A', suit='hearts')Card(rank='A', suit='spades')#----------------------------------&gt;&gt;&gt; from frenchDeck import *&gt;&gt;&gt; deck = FrenchDeck()&gt;&gt;&gt; len(deck) //计算对象总数52&gt;&gt;&gt; deck[0]Card(rank='2', suit='spades')&gt;&gt;&gt; deck[1]Card(rank='3', suit='spades')&gt;&gt;&gt; deck[13]Card(rank='2', suit='hearts')&gt;&gt;&gt; deck[-1]Card(rank='A', suit='diamonds')&gt;&gt;&gt; from random import choice&gt;&gt;&gt; choice(deck) //随机获取一组对象Card(rank='J', suit='spades')&gt;&gt;&gt; choice(deck)Card(rank='3', suit='hearts')&gt;&gt;&gt; deck[:3] //索引前三张牌[Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')]&gt;&gt;&gt; deck[12::13] //先抽出索引是 12 的那张牌，然后每隔 13 张牌拿 1 张[Card(rank='A', suit='spades'), Card(rank='A', suit='hearts'), Card(rank='A', suit='clubs'), Card(rank='A', suit='diamonds')]&gt;&gt;&gt; for card in deck: //遍历对象... print(card)... Card(rank='2', suit='spades')Card(rank='3', suit='spades')Card(rank='4', suit='spades')...Card(rank='Q', suit='diamonds')Card(rank='K', suit='diamonds')Card(rank='A', suit='diamonds')&gt;&gt;&gt; for card in reversed(deck): //反向遍历... print(card)... Card(rank='A', suit='diamonds')Card(rank='K', suit='diamonds')Card(rank='Q', suit='diamonds')...Card(rank='4', suit='spades')Card(rank='3', suit='spades')Card(rank='2', suit='spades')&gt;&gt;&gt; Card('Q', 'diamonds') in deck //判断是否在对象组里True&gt;&gt;&gt; Card('2', 'spades') in deckTrue","link":"/posts/1328111034.html"},{"title":"Python面对对象","text":"面向对象简述Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 对象可以包含任意数量和类型的数据。 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 类定义1234567class ClassName: &lt;statement-1&gt; . . . &lt;statement-N&gt;# 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 类对象 类对象的两种用法: 属性引用和实例化 属性引用和Python中所有的属性引用语法相同：object.name 1234567891011121314class Myclass: a = 1 def func(self): return &quot;hello world!&quot;# 实例化类x = Myclass() # 访问类的属性和方法print(&quot;Myclass 类的属性i 为：&quot;, x.i)print(&quot;Myclass 类的方法func为：&quot;, x.func())#结果Myclass 类的属性i 为：1Myclass 类的方法func为: hello world! 类有一个名为 _init_() 的特殊方法（构造方法），该方法在类实例化时会自动调用 12345678class Complex: def __init__(self, realpart, imagpart) self.r = realpart self.i = imagpartx = Complex(3.0, -2,5)print(x.r, x.i)#结果3.0 -2.5 self代表类的实例 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self 123456789class Test: def func(self): print(self) print(self.__class__)y = Text()y.yunc()# 结果&lt;__main__.Test object at 0x7fa4e933a3a0&gt; # 类对象所在的地址&lt;class '__main__.Test'&gt; # self为Test类的实例 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例 123456789101112131415&gt;&gt;&gt; class people:... name = ''... age = '' # 定义基本属性... __weight = 0 # 定义私有属性,私有属性在类外部无法直接进行访问... ... def __init__(self,n, a, w): # 定义构造方法... self.name = n... self.age = a... self.__weight = w... def speak(self):... print(&quot;%s 说: 我 %d 岁。&quot; %(self.name, self.age))... &gt;&gt;&gt; p = people(&quot;xiaoli&quot;, 18, 55) # 类people实例化&gt;&gt;&gt; p.speak() # 调用speak方法（也叫函数）xiaoli 说: 我 18 岁。 继承 子类继承父类的属性和方法（派生类 DerivedClassName，基类 BaseClassName） class DerivedClassName(modname, BaseClassName): 123456789101112131415161718192021&gt;&gt;&gt; class people: # 父类定义... name='' # 定义基本属性... age=''... __weight = 0 # 定义私有属性,私有属性在类外部无法直接进行访问... def __init__(self,n,a,w): # 定义构造方法... slef.name = n... self.age = a... self.__weight = w... def speak(self):... print(&quot;%s说：我%d岁。&quot; %(self.name,self.age))&gt;&gt;&gt; class student(people): # 单继承示例 （子类）... grade = ''... def __init__(self,n,a,w,g):... people.__init__(self,n,a,w) # 调用父类的构函... self.grade = g... def speak(self): # 重写父类的方法... print(&quot;%s 说：我%d岁，我在读%d年级&quot; %(self.name, self.age,self.grade))... &gt;&gt;&gt; s = student(&quot;小李&quot;, 10,50,5)&gt;&gt;&gt; s.speak()小李 说：我10岁，我在读5年级 多继承 class DerivedClassName(Base1, Base2, Base3): 注意圆括号中父类的顺序 若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法 1234567891011121314151617181920212223242526272829303132333435363738class people: name='' age='' __weight=0 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(f&quot;{self.name}说:我{self.age}岁！&quot;)# 单继承示例class student(people): grade='' def __init__(self,n,a,w,g): people.__init__(self,n,a,w) self.grade = g def speak(self): print(f&quot;{self.name}说：我读{self.grade}年级！&quot;)class speaker(): topic='' name='' def __init__(self,n,t): self.name=n self.topic=t def speak(self): print(f&quot;我叫{self.name},我是一个演说家，演讲的主题是{self.topic}&quot;)# 多重继承class sample(speaker,student): def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t)test = sample('Tim',25,65,4,'English')test.speak() # 方法名同，默认调用的是在括号中排前地父类的方法#结果我叫Tim,我是一个演说家，演讲的主题是English 方法重写1234567891011121314class Parent: # 定义父类 def myMethod(self): print('调用父类方法')class Child(Parent): # 定义子类 def myMethod(self): print('调用子类方法')c = Child() # 实例化c.myMethod() # 子类调用方法重写super(Child,c).myMethod() #用子类对象调用，父类覆盖相同的方法 super()函数是用于调用父类#结果调用子类方法调用父类方法 类属性与方法 类的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例 类的私有方法 __private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods 12345678910111213class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount +=1 self.publicCount +=1 print(self.__secretCount)counter = JustCounter()counter.count() # 输出 1counter.count() # 输出 2print(counter.publicCount) #输出 2，反应上次publicCount的值 print(counter.__secretCount) # 私有属性在类外部无法调用，报错 类的私有方法 12345678910111213141516171819class Site: def __init__(self, name, url): self.name =name # public self.url = url # private def who(self): print(f&quot;name: {self.name}&quot;) print(f&quot;url: {self.url}&quot;) def __foo(self): # 私有方法 print('私有方法') def foo(self): # 公开方法 print('公开方法') self.__foo()a = Site('百度','www.baidu.com') # 实例化a.who() # 调whoa.foo() # 调foo及__foo()方法a.__foo() # 私有方法无法访问 类的专用方法 _init_: 构造函数，在生成对象时调用 _del_: 析构函数，释放对象时使用 _repr_: 打印、转换 _setitem_: 按照索引赋值 _getitem_: 按照索引获值 _len_: 获得长度 _cmp_: 比较运算 _call_: 函数调用 _add_: 加运算 _sub_: 减运算 _mul_: 乘运算 _truediv_: 除运算 _mod_: 求余运算 _pow_: 乘方运算 运算符重载 对类的专有方法进行重载 12345678910111213141516class Vector: def __init__(self,a,b): self.a =a self.b=b def __str__(self): return f'Vector ({self.a},{self.b})' def __add__(self,other): return Vector(self.a + other.a,self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print(v1 + v2) # 调用__str__#结果Vector (7,8)","link":"/posts/1372953673.html"},{"title":"Markdown基本使用","text":"文章中图片排版格式 横向排列 12345&lt;div class=&quot;img-x&quot;&gt;-----留空格-----![图片链接](url)-----留空格-----&lt;/div&gt; 竖向排列 12345&lt;div class=&quot;img-y&quot;&gt;-----留空格-----![图片链接](url)-----留空格-----&lt;/div&gt; 横竖排列 12345&lt;div class=&quot;justified-gallery&quot;&gt;-----留空格-----![图片链接](url)-----留空格-----&lt;/div&gt; Markdown图片排版在Hexo注意问题 修改gallery.js文件(没有该文件的新建)： 12345678910111213141516171819// themes/icarus/source/js/gallery.js$(function(){ if (typeof ($.fn.justifiedGallery) === 'function') {+ let justifiedGallery = $('.justified-gallery')+ if(justifiedGallery.length &gt; 0) {+ for (let i = 0; i &lt; justifiedGallery.length; i ++){+ let html = justifiedGallery[i].childNodes[0].innerHTML+ justifiedGallery[i].innerHTML = html+ }+ }+ justifiedGallery.justifiedGallery({ cssAnimation: true, imagesAnimationDuration: 1000 }); } if (typeof ($.fn.lightGallery) === 'function') { $('.article').lightGallery({ selector: '.gallery-item' }); }}) 全局配置hexo文件，在**_config.yml**中添加如下 123456789# 压缩 jsneat_js: enable: true mangle: true output: compress: exclude: #设置忽略压缩文件 - '**/gallery.js' - '**/back-to-top.js' markdown图片排版问题详情 可以参考该博客链接 彩色标题带 粉红色彩带 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;div class=&quot;notification is-danger&quot;&gt;{% endraw %}-----内容-----{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;article class=&quot;message is-danger&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}-----内容-----{% raw %}&lt;/div&gt;{% endraw %} 淡蓝色彩带 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;div class=&quot;notification is-info&quot;&gt;{% endraw %}-----内容-----{% raw %}&lt;/div&gt;{% endraw %} Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 123{% raw %}&lt;article class=&quot;message is-info&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;{% endraw %}-----内容-----{% raw %}&lt;/div&gt;{% endraw %} 本文同时提供以下语言的翻译： English. 123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-globe-americas mr-2&quot;&gt;&lt;/i&gt;本文同时提供以下语言的翻译： &lt;a href=&quot;/hexo-theme-icarus/uncategorized/getting-started-with-icarus/&quot;&gt;English&lt;/a&gt;. &lt;/div&gt;&lt;/article&gt; 文章内容有误？点击此处提交修改。 12345&lt;article class=&quot;message message-immersive is-warning&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;文章内容有误？点击&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/ppoffice/hexo-theme-icarus/edit/site/source/_posts/zh-CN/Getting-Started.md&quot;&gt;此处&lt;/a&gt;提交修改。 &lt;/div&gt;&lt;/article&gt; 特殊符号插入 如： æ γ Π 复制代码号时，注意带上分号； 特殊符号链接 在Icarus主题文章某个代码块折叠使用方式 \\``` python main.md &gt;folded 在添加代码块的同时，加上代码块名main.md(自定义)，再加上“&gt;folded”,如上所述 (注：在icarus主题博客中main.js 文件已经定义floded功能，用法如上) 相册排版演示 按钮代码演示 Info Success Warning Danger buttons >folded123456&lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;button is-info&quot;&gt;Info&lt;/button&gt; &lt;button class=&quot;button is-success&quot;&gt;Success&lt;/button&gt; &lt;button class=&quot;button is-warning&quot;&gt;Warning&lt;/button&gt; &lt;button class=&quot;button is-danger&quot;&gt;Danger&lt;/button&gt;&lt;/div&gt; 显示一言 ↑↑↑ 试着点击“显示一言”！ function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/?c=b', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } }); } buttons >folded12345678910111213141516&lt;button class=&quot;button is-info&quot; onclick=&quot;showHitokoto(event)&quot;&gt;显示一言&lt;/button&gt;&lt;blockquote class=&quot;hitokoto&quot;&gt;↑↑↑ 试着点击“显示一言”！&lt;/blockquote&gt;&lt;script&gt;function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: '', //此处为存储数据条连接 success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } });}&lt;/script&gt; 样式书写演示看一看，说一说 欢迎畅所欲言，留下宝贵意见 12&lt;center&gt;&lt;font color=#6190e8 face=&quot;黑体&quot; size=5&gt;看一看，说一说&lt;/font&gt;&lt;/center&gt;&lt;center&gt;&lt;font color=#6190e8 face=&quot;黑体&quot; size=5&gt;欢迎畅所欲言，留下宝贵意见&lt;/font&gt;&lt;/center&gt; 函数公式书写演示daima.md >folded123456789101112131415161718这是一个行内公式：\\\\(ax^2+bx+c=0\\\\)。这是另一个行内公式：$ax^2+bx+c&gt;0$。这是一个块状公式：$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$这是另一个块状公式：\\\\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\\\]或者使用\\\\(\\LaTeX\\\\)环境：\\\\begin{equation}A =\\\\begin{bmatrix} a &amp; b \\\\\\\\ c &amp; c\\\\end{bmatrix}\\\\end{equation} 这是一个行内公式：\\(ax^2 + bx + c=0\\)。这是另一个行内公式：$ax^2 + bx + c &gt; 0$。 这是一个块状公式： $$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}​{1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$ ​ 这是另一个块状公式： \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\]","link":"/posts/3133288005.html"},{"title":"初始化Django项目一般流程(虚拟环境env)","text":"初始化项目环境要求 vs code python3.8或更高的版本 Django最新版本(在虚拟环境中安装) 注：此项目演示在Ubuntu 20.04.3 LTS 中，在Linux系统中类似 一般过程 在某个位置，新建一个文件夹storefront，并进入文件夹内 用pipenv 安装django，前提python中有pipenv包(或者pip3 install pipenv) 在当前文件位置启动Vscode，可以看到pipfile 和 Pipfile.lock 两个文件 激活python虚拟环境，命令 pipenv shell 命令行前面多出小括号如(storefront)表示虚拟环境激活 django-admin 可以查看所有的子命令 新建一个项目storefront ，命令 django-admin startproject storefront . (此处点意思以当前为目录项目名) 本地启动django，命令 python manage.py runserver (端口默认8000，可自定义端口如python manage.py runserver 8080) 红色提示 : ”Run ‘python manage.py migrate’ to apply them.” ，表示该项目还没有进行数据库迁移绑定 http://127.0.0.1:8000/ 为django在浏览器启动本地ip，8000为默认端口，如下表示启动成功 在vscode终端terminal 启动django，先在terminal查看安装django中python解释器位置，命令 pipenv –venv ctrl + shift + p 打开 vs code常用搜索栏，输入 python: Select Interpreter ，选择对应上面位置python解释器 pipenv shell 激活python虚拟环境，命令行前面多出小括号如（storefront），表示虚拟环境激活，deactivate 表示退出虚拟环境 python manage.py runserver 启动django项目 创建项目子应用playground，命令 python manage.py startapp playground 数据库迁移 python manage.py makemigrations 生成迁移（如生成一个0001_initial.py文件） python manage.py migrate 执行迁移（根据0001_initial.py文件执行表格迁移） python manage.py migrate store 0003 执行迁移回退上一步（对应的应用store，回退到的版本0003）","link":"/posts/2752460855.html"},{"title":"内置函数(二)","text":"第一部分详见上文。。。内置函数(一) bytes()[^1] #返回新的bytes对象，是一个0&lt;= x &lt;=256之间的整数不可变序列 1234567891011&gt;&gt;&gt; a = bytes([1,2,3,4])&gt;&gt;&gt; ab'\\x01\\x02\\x03\\x04'&gt;&gt;&gt; type(a)&lt;class 'bytes'&gt;&gt;&gt;&gt; &gt;&gt;&gt; a = bytes('hello','ascii')&gt;&gt;&gt; ab'hello'&gt;&gt;&gt; type(a)&lt;class 'bytes'&gt; float() #用于将整数和字符串转换成浮点数 123456&gt;&gt;&gt; float(1)1.0&gt;&gt;&gt; float(-112.3)-112.3&gt;&gt;&gt; float('11')11.0 iter() #用来生成迭代器 1234567&gt;&gt;&gt; li = [1,2,3]&gt;&gt;&gt; for x in iter(li):... print(x)... 123 print() #用于打印输出 print(*objects, sep=‘ ’, end=‘\\n’, file=sys.stdout, flush=False ) objects – 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。 sep – 用来间隔多个对象，默认值是一个空格。 end – 用来设定以什么结尾。默认值是换行符 \\n，我们可以换成其他字符串。 file – 要写入的文件对象。 flush – 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。 12345678910111213141516171819&gt;&gt;&gt; print(1)1&gt;&gt;&gt; print(&quot;hello,world&quot;)hello,world&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = &quot;hello&quot;&gt;&gt;&gt; print(a,b)1 hello&gt;&gt;&gt; print(&quot;aa&quot;,&quot;b&quot;)aa b&gt;&gt;&gt; print(&quot;aaa&quot;&quot;bbb&quot;)aaabbb&gt;&gt;&gt; print(&quot;I&quot;,&quot;am&quot;,&quot;a&quot;,&quot;student&quot;,sep=' ') //设置间断符I am a student#--------------------------------------&gt;&gt;&gt; import time&gt;&gt;&gt; for i in range(10):... print(&quot;。&quot;,end=&quot;&quot;,flush = True)... time.sleep(0.5) //输出结果为：间断0.5s输出句号。 tuple #将可迭代对象（如列表）转化成元组 12345678910111213141516171819&gt;&gt;&gt; li = ['I','am','a','student']&gt;&gt;&gt; tuple1 = tuple(li)&gt;&gt;&gt; tuple1('I', 'am', 'a', 'student')#-------------------------------&gt;&gt;&gt; a= 'www' &gt;&gt;&gt; b = tuple(a) //将字符串转化成元组&gt;&gt;&gt; b('w', 'w', 'w')&gt;&gt;&gt; a = {'www':123,'ttt':456} //将字典的key转化成元组&gt;&gt;&gt; b = tuple(a)&gt;&gt;&gt; b('www', 'ttt')&gt;&gt;&gt; a = set('abcd') //将集合转化成元组&gt;&gt;&gt; b = tuple(a)&gt;&gt;&gt; b('a', 'd', 'b', 'c') //元组形式&gt;&gt;&gt; a{'a', 'd', 'b', 'c'} //集合形式 callable() #用于检查一个对象是否可以调用 对于函数、方法、lambda函式、类以及实现了__ all__ 方法的类实例，它的返回True 123456789101112131415161718192021222324252627&gt;&gt;&gt; callable(0)False&gt;&gt;&gt; callable('hello')False&gt;&gt;&gt; def add(a,b):... return a+b... &gt;&gt;&gt; callable(add) //函数True&gt;&gt;&gt; class A: ... def method(self):... return 0... &gt;&gt;&gt; callable(A) //类返回TrueTrue&gt;&gt;&gt; a = A() //没有实现__call__,返回 False&gt;&gt;&gt; callable(a)False&gt;&gt;&gt; class B:... def __call__(self):... return 0... &gt;&gt;&gt; callable(B)True&gt;&gt;&gt; b = B()&gt;&gt;&gt; callable(b) //实现__call__,返回 TrueTrue format() #格式化函数，可以接受不限个参数 1234567891011121314151617181920212223&gt;&gt;&gt; &quot;{} {}&quot;.format(&quot;hello&quot;,&quot;world&quot;)'hello world'&gt;&gt;&gt; &quot;{0} {1}&quot;.format(&quot;hello&quot;,&quot;world&quot;)'hello world'&gt;&gt;&gt; &quot;{1} {0} {1}&quot;.format(&quot;hello&quot;,&quot;world&quot;)'world hello world'&gt;&gt;&gt; print(&quot;网站:{name},url:{url}&quot;.format(name=&quot;博客&quot;,url=&quot;bingeone.top&quot;))网站:博客,url:bingeone.top#--------------------------------------------------&gt;&gt;&gt; site = {&quot;name&quot;:&quot;博客&quot;,&quot;url&quot;:&quot;bingeone.top&quot;}&gt;&gt;&gt; print(&quot;网站:{name},url:{url}&quot;.format(**site)) //字典调用网站:博客,url:bingeone.top&gt;&gt;&gt; li = ['博客','bingeone.top']&gt;&gt;&gt; print(&quot;网站:{0[0]},url:{0[1]}&quot;.format(li)) //列表调用，0指定li列表对象网站:博客,url:bingeone.top#---------------------------------------------------&gt;&gt;&gt; class AssignValue(object):... def __init__(self,value):... self.value = value... &gt;&gt;&gt; my_value = AssignValue(5)&gt;&gt;&gt; print(&quot;value 为:{0.value}&quot;.format(my_value))value 为:5 数字格式化 1234567891011121314151617&gt;&gt;&gt; print(&quot;{:.2f}&quot;.format(3.1415926))3.14&gt;&gt;&gt; print(&quot;{} 对应的位置是{{0}}&quot;.format(&quot;bingeone&quot;))bingeone 对应的位置是{0}#-----------进制转化-----------&gt;&gt;&gt; '{:b}'.format(11)'1011'&gt;&gt;&gt; '{:d}'.format(11)'11'&gt;&gt;&gt; '{:o}'.format(11)'13'&gt;&gt;&gt; '{:x}'.format(11)'b'&gt;&gt;&gt; '{:#x}'.format(11)'0xb'&gt;&gt;&gt; '{:#X}'.format(11)'0XB' 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:&gt;10d} 13 右对齐 (默认, 宽度为10) len() #返回对象(字符，列表，元组等)长度或者项目个数 1234567&gt;&gt;&gt; str = &quot;bingeone&quot;&gt;&gt;&gt; len(str)8&gt;&gt;&gt; &gt;&gt;&gt; ll = [1,2,3,4]&gt;&gt;&gt; len(ll)4 property() #在新式类中返回属性值 12345678910111213141516171819202122232425262728293031property.md &gt;foldedclass A(object): def __init__(self): self._x = None def getx(self): //获取x的值 return self._x def setx(self): //设置x的值 self._x = value def delx(self): //删除x的值 del self._x x = property(getx,setx,delx, &quot;I'm the 'x' property&quot;)#------------------------两种写法------------------------------class A(object): def __init__(self): self._x = None @property def x(self): //获取x的值 return self._x @x.setter def x(self): //设置x的值 self._x = value @x.deleter def x(self): //删除x的值 del self._x type() #一个参数返回对象的类型，三个参数返回新的类型对象 type(object) type(name, bases, dict) 12345678910111213141516171819&gt;&gt;&gt; type(1)&lt;class 'int'&gt;&gt;&gt;&gt; type(&quot;bingeone&quot;)&lt;class 'str'&gt;&gt;&gt;&gt; type([11,22])&lt;class 'list'&gt;&gt;&gt;&gt; type({1:'aa'})&lt;class 'dict'&gt;&gt;&gt;&gt; x = 'a'&gt;&gt;&gt; x = 1&gt;&gt;&gt; type(x) == int //判断类型True#--------------------------------&gt;&gt;&gt; class X(object):... a = 1... &gt;&gt;&gt; X = type(&quot;X&quot;, (object,), dict(a=1)) //产生一个新的类型 X&gt;&gt;&gt; X&lt;class '__main__.X'&gt; chr() #一个整数作为参数，返回一个对应的字符 123456&gt;&gt;&gt; chr(65)'A'&gt;&gt;&gt; chr(97)'a'&gt;&gt;&gt; chr(8364)'€' frozenset() #返回一个冻结的集合，冻结后集合不能再添加任何元素 123456&gt;&gt;&gt; a = frozenset(range(5))&gt;&gt;&gt; afrozenset({0, 1, 2, 3, 4}) //生成一个不可变的集合&gt;&gt;&gt; b = frozenset(&quot;bingeone&quot;)&gt;&gt;&gt; bfrozenset({'g', 'b', 'o', 'i', 'n', 'e'}) list() #用于将元组或者字符串转化成列表 12345678&gt;&gt;&gt; _tuple = (123,'baidu','www')&gt;&gt;&gt; li = list(_tuple)&gt;&gt;&gt; li[123, 'baidu', 'www']&gt;&gt;&gt; str = 'hello, world'&gt;&gt;&gt; li2 = list(str)&gt;&gt;&gt; li2['h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd'] range() #返回的是一个可迭代对象(类型是对象)，而不是列表类型 list()函数是一个对象迭代器，可以把range()返回的可迭代对象转化成一个列表 range(stop) range(start, stop, step) 123456789101112131415&gt;&gt;&gt; range(5)range(0, 5)&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]&gt;&gt;&gt; list(range(0))[]&gt;&gt;&gt; list(range(0,10,2)) //给出起点, 终点(到不了的), 步长(正整数,负整数)[0, 2, 4, 6, 8]&gt;&gt;&gt; list(range(0,-10,-2))[0, -2, -4, -6, -8]&gt;&gt;&gt; list(range(1,0))[]&gt;&gt;&gt; a = range(2,2046,2)&gt;&gt;&gt; print(a[0],a[1],a[len(a)-1])2 4 2044 vars() #函数返回对象object的属性和属性值的字典对象 123456789&gt;&gt;&gt; print(vars(A)){'__module__': '__main__', 'a': 1, '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None}&gt;&gt;&gt; a= A()&gt;&gt;&gt; print(vars(a)){}&gt;&gt;&gt; x = 1&gt;&gt;&gt; scope = vars()&gt;&gt;&gt; scope[&quot;x&quot;]1 classmethod() #对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的的cls参数，可以用来调用类的属性，类的方法，实例化对象等 1234567891011121314&gt;&gt;&gt; class A(object):... bar = 1... def func1(self): ... print('www')... @classmethod //类方法修饰... def func2(cls):... print('111') ... print(cls.bar) //调用类的属性... cls().func1() //调用类的方法... &gt;&gt;&gt; A.func2() //实例化对象1111www getatter() #返回对象的属性值 1234567891011121314151617181920&gt;&gt;&gt; class A(object):... bar = 1... &gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a,&quot;bar&quot;) //获取bar 属性1&gt;&gt;&gt; getattr(a,&quot;bar1&quot;,2) //没有bar1属性，需要设置默认值，为22#---------------------------------&gt;&gt;&gt; class B(object):... def set(self,a,b):... x = a... a = b... b = x... print(a,b)... &gt;&gt;&gt; bb = B()&gt;&gt;&gt; cc = getattr(bb,&quot;set&quot;)&gt;&gt;&gt; cc(a=1,b=2)2 1 locals() #以字典的形式返回当前位置的全部局部变量 123456&gt;&gt;&gt; def A(arg): //两个局部变量：arg z... z= 11... print(locals())... &gt;&gt;&gt; A(22){'arg': 22, 'z': 11} //返回一个名字/值对的字典 repr() #将对象转化为供解释器读取的形式 123456&gt;&gt;&gt; a = 'aabbcc'&gt;&gt;&gt; repr(a)&quot;'aabbcc'&quot;&gt;&gt;&gt; li = [1,2,3,4]&gt;&gt;&gt; repr(li)'[1, 2, 3, 4]' zip() #将可迭代的对象作为参数，将对象对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样的作用可以节约内存 12345678910111213141516&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) //返回对象&gt;&gt;&gt; zipped&lt;zip object at 0x7fa2f71d36c0&gt; //对象地址&gt;&gt;&gt; list(zipped) //罗列对象成列表形式[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) //元素的个数与最短的列表一样[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) //与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6] compile() #将一个字符串编译为字节代码 compile(source, filename, mode[, flags[,dont_inherit]]) source – 字符串或者AST（Abstract Syntax Trees）对象。。 filename – 代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。 mode – 指定编译代码的种类。可以指定为 exec, eval, single。 flags – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。。 flags和dont_inherit是用来控制编译源码时的标志 123456789101112131415161718&gt;&gt;&gt; str = &quot;for i in range(1,10): print(i)&quot;&gt;&gt;&gt; c = compile(str,&quot;&quot;,&quot;exec&quot;) //编译为字节代码对象&gt;&gt;&gt; c&lt;code object &lt;module&gt; at 0x7fa2f71ed5b0, file &quot;&quot;, line 1&gt;&gt;&gt;&gt; exec(c)123456789&gt;&gt;&gt; str = &quot;3*4+5&quot;&gt;&gt;&gt; a = compile(str,&quot;&quot;,&quot;eval&quot;)&gt;&gt;&gt; eval(a)17 globals() #以字典的形式返回当前位置的全部全局变量 123&gt;&gt;&gt; a = 123&gt;&gt;&gt; print(globals()){'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'a': 123} map() #根据提供的函数对序列做映射 123456789&gt;&gt;&gt; def square(x): ... return x**2 //返回x 的平方... &gt;&gt;&gt; map(square, [1,2,3,4]) //计算列表中各元素的平方&lt;map object at 0x7fa4ad1d2f10&gt; //返回迭代器&gt;&gt;&gt; list(map(square, [1,2,3,4])) //转化成列表[1, 4, 9, 16]&gt;&gt;&gt; list(map(lambda x:x**2, [1,2,3,4])) //使用 lambda 匿名函数[1, 4, 9, 16] reversed() #返回一个反转的迭代器 123456789101112131415&gt;&gt;&gt; seqString = '12345'&gt;&gt;&gt; print(list(reversed(seqString)))['5', '4', '3', '2', '1']&gt;&gt;&gt; seqTuple = (1,2,3,4)&gt;&gt;&gt; print(list(reversed(seqTuple)))[4, 3, 2, 1]&gt;&gt;&gt; seqRange = range(1,5)&gt;&gt;&gt; print(list(reversed(seqRange)))[4, 3, 2, 1]&gt;&gt;&gt; seqList = [1,2,3,4]&gt;&gt;&gt; print(list(reversed(seqList)))[4, 3, 2, 1] __import__() #用于动态加载类和函数 12&gt;&gt;&gt; import sys&gt;&gt;&gt; __import__('p01.py') # 导入 p01.py 模块 complex() #用于创建一个值为renl + imag*j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数 12345678&gt;&gt;&gt; complex(1, 2)(1+2j)&gt;&gt;&gt; complex(1) //数字(1+0j)&gt;&gt;&gt; complex(&quot;1&quot;) //字符串(1+0j)&gt;&gt;&gt; complex(&quot;1+2j&quot;) //这个地方在&quot;+&quot;号两边不能有空格，也就是不能写成&quot;1 + 2j&quot;，应该是&quot;1+2j&quot;，否则会报错(1+2j) hasattr() #用于判断对象是否包含对应的属性 12345678910&gt;&gt;&gt; class Coordinate:... x = 10... y = -2... z = 0... &gt;&gt;&gt; p = Coordinate()&gt;&gt;&gt; print(hasattr(p,&quot;x&quot;))True&gt;&gt;&gt; print(hasattr(p,&quot;no&quot;)) //没有对应的属性False max() #返回给定的最大值，参数可以为序列 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; print(&quot;max(80,30,50,75):&quot;,max(80,30,50,75))max(80,30,50,75): 80#----------------------------------------------#max(x, y[, z...]):Number|Sequence 入参类型不能混入（要么全Number(int|float|complex|bool），要么全序列）。#单序列入参，返回序列中最大的一个数值多序列入参, 按索引顺序，逐一对比各序列的当前索引位的 “值”，直到遇见最大值立即停止对比，并返回最大值所在的序列（也就是说，多序列入参，返回值依旧是一个序列，而不是数值）&gt;&gt;&gt; max(0,True) //bool True&gt;&gt;&gt; max([1,2,3]) //单序列3&gt;&gt;&gt; max(1,2,4)4&gt;&gt;&gt; max(-1,-0.5,-0)0&gt;&gt;&gt; max((1,2,3))3&gt;&gt;&gt; max([2,4],[3,6]) //多序列，按索引位置比较[3, 6]&gt;&gt;&gt; max([2,4],[1,5])[2, 4]&gt;&gt;&gt; max([2,4],[1,5],[3,1])[3, 1]&gt;&gt;&gt; max((1,2,3),(3,3,0))(3, 3, 0)&gt;&gt;&gt; max((1,-1,0),(True,False,0)) //bool，多序列(True, False, 0)&gt;&gt;&gt; max((1,-1,0),(True,False,2,0),(1,0,0,2))(True, False, 2, 0)&gt;&gt;&gt; max((1,-1,0),(True,),(1,))(1, -1, 0)&gt;&gt;&gt; max((-1,-1,0),(True,),(1,))(True,)&gt;&gt;&gt; max([1,2,3],3,4) //number 和 序列混杂报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: '&gt;' not supported between instances of 'int' and 'list'&gt;&gt;&gt; max((1,2,3),[1,2,3]) //不同类型序列，报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: '&gt;' not supported between instances of 'list' and 'tuple' round() #返回浮点数x的四舍五入，准确的说保留到离上一位更近的一端（四舍六入），精度要求较高的，一般不使用该函数 123456789101112131415&gt;&gt;&gt; print(&quot;round(70.23456):&quot;,round(70.23456))round(70.23456): 70&gt;&gt;&gt; print(&quot;round(56.659,1):&quot;,round(56.659,1))round(56.659,1): 56.7&gt;&gt;&gt; print(&quot;round(80.264,2):&quot;,round(80.264,2))round(80.264,2): 80.26&gt;&gt;&gt; print(&quot;round(100.000056,3):&quot;,round(100.000056,3))round(100.000056,3): 100.0&gt;&gt;&gt; print(&quot;round(-100.000056,3):&quot;,round(-100.000056,3))round(-100.000056,3): -100.0&gt;&gt;&gt; print(&quot;round(2.675,2):&quot;,round(2.675,2)) round(2.675,2): 2.67# 按我们的想法返回结果应该是 2.68，可结果却是 2.67，为什么？# 这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串 1 和 0 后可能是无限位数的，机器已经做出了截断处理。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离 2.67 要更近一点点，所以保留两位小数时就近似到了 2.67。 delattr() #用于删除函数属性 1234567891011121314151617181920212223&gt;&gt;&gt; class Coordinate:... x =10... y = 1... z = 0... &gt;&gt;&gt; p = Coordinate()&gt;&gt;&gt; print(&quot;x=:&quot;,p.x)x=: 10&gt;&gt;&gt; print(&quot;y=:&quot;,p.y)y=: 1&gt;&gt;&gt; print(&quot;z=:&quot;,p.z)z=: 0&gt;&gt;&gt; &gt;&gt;&gt; delattr(Coordinate,&quot;z&quot;) //删除类中 z的属性&gt;&gt;&gt; &gt;&gt;&gt; print(&quot;x=:&quot;,p.x)x=: 10&gt;&gt;&gt; print(&quot;y=:&quot;,p.y)y=: 1&gt;&gt;&gt; print(&quot;z=:&quot;,p.z) //类中没有该属性，报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: 'Coordinate' object has no attribute 'z' hash() #返回对象的哈希值 12345678&gt;&gt;&gt; hash('test')3938127732211961192&gt;&gt;&gt; hash(1)1&gt;&gt;&gt; hash(str([1,2,3]))-8986991832632495888&gt;&gt;&gt; hash(str(sorted({'1':1})))341477958600190998 memoryview() #返回给定参数的内存查看对象（memory view） 所谓内存查看对象，是指支持缓冲协议的数据进行包装，在不需要复制对象基础上允许python代码访问 123456789&gt;&gt;&gt; a = memoryview(bytearray(&quot;abcefg&quot;,&quot;utf-8&quot;))&gt;&gt;&gt; print(a[0]) //索引 0位的asii码97&gt;&gt;&gt; print(a[-1])103&gt;&gt;&gt; print(a[1:4])&lt;memory at 0x7fa845b14580&gt;&gt;&gt;&gt; print(a[1:4].tobytes())b'bce' toBytes()方法是将参数使用UTF-8的编码格式转换成byte[],getBytes()是用读取file.encoding的编码格式,然后用读取的格式进行转换, set() #创建一个无序不重复元素集，可以进行关系测试，删除重复数据，还可以计算交集，差集，并集等 交集 &amp; : x&amp;y，返回一个新的集合，包括同时在集合 x 和y中的共同元素。 并集 | : x|y，返回一个新的集合，包括集合 x 和 y 中所有元素。 差集 - : x-y，返回一个新的集合,包括在集合 x 中但不在集合 y 中的元素。 补集 ^ : x^y，返回一个新的集合，包括集合 x 和 y 的非共同元素。 1234567891011121314&gt;&gt;&gt; x = set('alibaba')&gt;&gt;&gt; y = set('google')&gt;&gt;&gt; x,y({'i', 'a', 'l', 'b'}, {'e', 'o', 'l', 'g'})&gt;&gt;&gt; x &amp; y{'l'}&gt;&gt;&gt; x | y{'o', 'a', 'i', 'l', 'e', 'g', 'b'}&gt;&gt;&gt; x - y{'i', 'a', 'b'}&gt;&gt;&gt; x ^ y{'o', 'a', 'b', 'i', 'e', 'g'}&gt;&gt;&gt; y ^ x{'o', 'a', 'i', 'e', 'g', 'b'} ​ 以上总共68个python内置函数，学习资料来自菜鸟教程 内置函数 abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() delattr() hash() memoryview() set()","link":"/posts/1555555841.html"},{"title":"视频页测试","text":"视频嵌入md演示 外部视频链接，引入markedown进行样式包装演示，链接封装还有待优化。 video >folded123&lt;div style=&quot;position:relative; padding-bottom:75%; width:100%; height:0&quot;&gt; &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=289911559&amp;bvid=BV1Af4y147Jv&amp;cid=319275725&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position:absolute; height: 100%; width: 100%;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 方式一 方式二","link":"/posts/3282361534.html"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Typora","slug":"Typora","link":"/tags/Typora/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"程序","slug":"程序","link":"/tags/%E7%A8%8B%E5%BA%8F/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"pipenv","slug":"pipenv","link":"/tags/pipenv/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"django","slug":"django","link":"/tags/django/"},{"name":"B站","slug":"B站","link":"/tags/B%E7%AB%99/"}],"categories":[{"name":"软件","slug":"软件","link":"/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"fluent_python","slug":"fluent-python","link":"/categories/fluent-python/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"视频","slug":"视频","link":"/categories/%E8%A7%86%E9%A2%91/"}]}